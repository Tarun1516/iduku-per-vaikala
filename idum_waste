iam going to build an application for windows and linux and the application is about vpn detection and blocking and the name of teh application checkblock and i ahve decided to use QT framework for that and i have the codes for vpn_detection.py and the vpn_blockig.py and for the ui part also i have the codes .. 
i have 3 page and a login page that is started up on the 1st time of opening the application if the application is logged in then the login page no need show that application .. and the 3 pages are 
1. main page (the application works )
2. dashboard ( the datas that are sent and recorded from the main page)
3. profile ( the details that are fetched from the backend supabase when the user logged in )
4. the login page (that is asked only the 1st time after logging in , no need for this page .. the user can continue to use the application .. also the user can use the application only if it is logged in)
for which also the code is attached below 

#vpn_detection.py 

import requests
import socket
import json
import time
import ipaddress
from concurrent.futures import ThreadPoolExecutor
import re
import geocoder
import platform
import subprocess
import ssl
import urllib.request
import uuid
import struct
import hashlib
from datetime import datetime
import math

class EnhancedVPNDetector:
    def __init__(self, proxy_check_api_key=None, vpnapi_key=None, ipinfo_api_key=None):
        self.proxy_check_api_key = proxy_check_api_key
        self.vpnapi_key = vpnapi_key
        self.ipinfo_api_key = ipinfo_api_key
        
        # VPN port mapping for network scan
        self.vpn_provider_ports = {
            'OpenVPN': [1194, 1195, 1196, 1197, 443],
            'PPTP': [1723],
            'L2TP': [1701],
            'IKEv2': [500, 4500],
            'WireGuard': [51820, 51821, 51822],
            'SoftEther': [992, 5555],
            'Shadowsocks': [8388, 8389],
            'V2Ray': [10086, 10087],
            'Outline': [8900]
        }
        
        # Known VPN-related ASNs
        self.known_vpn_asns = [
            "AS9009",   # M247 - used by NordVPN
            "AS12989",  # HotspotShield
            "AS16276",  # OVH - used by many VPNs
            "AS20473",  # Choopa/Vultr - used by many VPNs
            "AS4766",   # Korea Telecom - used by some VPNs
            "AS174",    # Cogent - used by some VPNs
            "AS24940",  # Hetzner - used by VPN providers
            "AS14061",  # DigitalOcean
            "AS16509",  # Amazon AWS
            "AS26496",  # GoDaddy
            "AS46652",  # ServerRoom
            "AS30475",  # WeVPN
            "AS8100",   # QuadraNet
            "AS25369",  # Hydra Communications - ExpressVPN
            "AS15003",  # Nobis Technology - used by some VPNs
            "AS6453",   # TATA Communications - used by VPNs
            "AS15169",  # Google - used for Google VPN
            "AS1241",   # Forthnet - used by VPNs
            "AS7922",   # Comcast - sometimes used by VPNs
            "AS58224",  # Italia Online - used by VPNs in Italy
            "AS9050",   # RTD Network - used by ROMANIAS VPNs
            "AS203020", # VPN providers
            "AS211252", # Data Protection - VPNs
            "AS14576",  # Hosting Solution Ltd - VPNs
            "AS51167",  # ContabolMail - used by VPNs
            "AS42708",  # PortLane - used by VPNs
            "AS44477",  # Stark Industries - VPNs
            "AS49392",  # AsiaPac Communication - VPNs
        ]
    
    def get_local_ip(self):
        """Get the local machine's IP address with improved reliability"""
        candidate_ips = []
        
        # Method 1: Connect to external service
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 80))
            candidate_ips.append(s.getsockname()[0])
            s.close()
        except Exception as e:
            print(f"Method 1 error: {e}")
        
        # Method 2: Get hostname-based IP
        try:
            hostname = socket.gethostname()
            hostname_ip = socket.gethostbyname(hostname)
            if hostname_ip and hostname_ip != '127.0.0.1':
                candidate_ips.append(hostname_ip)
        except Exception as e:
            print(f"Method 2 error: {e}")
        
        # Method 3: Get all network interfaces
        try:
            if platform.system() == "Windows":
                # On Windows, use ipconfig to get all interfaces
                output = subprocess.check_output("ipconfig /all", shell=True).decode('utf-8')
                # Extract IPv4 addresses
                ip_pattern = r"IPv4 Address[\.\s]+: ([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)"
                ips = re.findall(ip_pattern, output)
                candidate_ips.extend(ips)
            else:
                # On Linux/Mac, use ifconfig
                interfaces = socket.if_nameindex()
                for _, interface_name in interfaces:
                    try:
                        interface_ip = socket.gethostbyname(interface_name)
                        if interface_ip and interface_ip != '127.0.0.1':
                            candidate_ips.append(interface_ip)
                    except:
                        pass
        except Exception as e:
            print(f"Method 3 error: {e}")
        
        # Filter and prioritize IPs
        valid_local_ips = []
        for ip in candidate_ips:
            try:
                ip_obj = ipaddress.ip_address(ip)
                # Filter for private IP ranges
                if ip_obj.is_private and not ip_obj.is_loopback:
                    valid_local_ips.append(ip)
            except:
                continue
        
        # Prioritize 192.168.x.x addresses which are most common for home networks
        for ip in valid_local_ips:
            if ip.startswith('192.168.'):
                return ip
        
        # Otherwise return first valid private IP or fallback to localhost
        return valid_local_ips[0] if valid_local_ips else '127.0.0.1'
    
    def get_public_ip(self):
        """Get the public-facing IP address"""
        try:
            response = requests.get("https://api.ipify.org?format=json", timeout=5)
            return response.json()["ip"]
        except Exception as e:
            print(f"Error getting public IP from ipify: {e}")
            try:
                # Fallback to another IP service
                response = requests.get("https://ifconfig.me/ip", timeout=5)
                return response.text.strip()
            except Exception as e2:
                print(f"Error getting public IP from ifconfig.me: {e2}")
                return None
    
    def get_location_data(self, ip_address, is_local=False):
        """Get detailed location data including coordinates for an IP address"""
        location_data = {
            "city": None,
            "region": None,
            "country": None,
            "country_code": None,
            "latitude": None,
            "longitude": None,
            "isp": None,
            "org": None,
            "asn": None,
            "timezone": None
        }
        
        # For local IP that's private, use multiple methods to determine location
        if is_local and ipaddress.ip_address(ip_address).is_private:
            # Method 1: Use public IP location as proxy for local machine location
            public_ip = self.get_public_ip()
            if public_ip:
                public_location = self.get_ipinfo_data(public_ip)
                if public_location:
                    location_data.update({
                        "city": public_location.get("city"),
                        "region": public_location.get("region"),
                        "country": public_location.get("country_name", public_location.get("country")),
                        "country_code": public_location.get("country"),
                        "latitude": None,
                        "longitude": None
                    })
                    
                    # Parse coordinates if available
                    if "loc" in public_location:
                        try:
                            lat, lng = map(float, public_location["loc"].split(","))
                            location_data["latitude"] = lat
                            location_data["longitude"] = lng
                        except Exception as e:
                            print(f"Error parsing coordinates from IPInfo: {e}")
                    
                    # Get ISP/org info
                    location_data.update({
                        "isp": public_location.get("org"),
                        "asn": public_location.get("asn"),
                        "timezone": public_location.get("timezone")
                    })
            
            # Method 2: Try system time zone for region data
            try:
                import tzlocal
                local_tz = tzlocal.get_localzone().zone
                if local_tz:
                    # Parse timezone like "America/New_York" to extract region info
                    tz_parts = local_tz.split('/')
                    if len(tz_parts) > 1:
                        # Don't overwrite if we already have data from Method 1
                        if not location_data["country"]:
                            location_data["country"] = tz_parts[0]
                        if not location_data["city"] and len(tz_parts) > 1:
                            location_data["city"] = tz_parts[-1].replace('_', ' ')
            except:
                pass
            
            # Method 3: Try geocoder as last resort
            try:
                system_geo = geocoder.ip('me')
                if system_geo and system_geo.ok and system_geo.latlng:
                    # Only update values that are still None
                    if not location_data["city"]:
                        location_data["city"] = system_geo.city
                    if not location_data["region"]:
                        location_data["region"] = system_geo.state
                    if not location_data["country"]:
                        location_data["country"] = getattr(system_geo, 'country_long', system_geo.country)
                    if not location_data["country_code"]:
                        location_data["country_code"] = system_geo.country
                    if not location_data["latitude"]:
                        location_data["latitude"] = system_geo.lat
                    if not location_data["longitude"]:
                        location_data["longitude"] = system_geo.lng
            except Exception as e:
                print(f"Error getting system geolocation: {e}")
        
        # For public IPs, continue with the existing methods
        else:
            # Try IPInfo API first
            if self.ipinfo_api_key or not is_local:
                ipinfo_data = self.get_ipinfo_data(ip_address)
                if ipinfo_data:
                    location_data.update({
                        "city": ipinfo_data.get("city"),
                        "region": ipinfo_data.get("region"),
                        "country": ipinfo_data.get("country_name", ipinfo_data.get("country")),
                        "country_code": ipinfo_data.get("country"),
                        "timezone": ipinfo_data.get("timezone"),
                        "org": ipinfo_data.get("org"),
                        "asn": ipinfo_data.get("asn")
                    })
                    
                    # Parse coordinates if available
                    if "loc" in ipinfo_data:
                        try:
                            lat, lng = map(float, ipinfo_data["loc"].split(","))
                            location_data["latitude"] = lat
                            location_data["longitude"] = lng
                        except Exception as e:
                            print(f"Error parsing coordinates from IPInfo: {e}")
            
            # If coordinates are still missing, try another service
            if location_data["latitude"] is None or location_data["longitude"] is None:
                try:
                    geo = geocoder.ip(ip_address)
                    if geo and geo.ok:
                        location_data.update({
                            "latitude": geo.lat,
                            "longitude": geo.lng,
                            "city": geo.city or location_data["city"],
                            "region": geo.state or location_data["region"],
                            "country": geo.country_long or location_data["country"],
                            "country_code": geo.country or location_data["country_code"]
                        })
                except Exception as e:
                    print(f"Error getting coordinates from geocoder: {e}")
        
        return location_data
    
    def get_ipinfo_data(self, ip_address):
        """Get detailed IP information from ipinfo.io"""
        url = f"https://ipinfo.io/{ip_address}/json"
        headers = {}
        if self.ipinfo_api_key:
            headers["Authorization"] = f"Bearer {self.ipinfo_api_key}"
            
        try:
            response = requests.get(url, headers=headers, timeout=5)
            if response.status_code == 200:
                data = response.json()
                # Add country_name if not present
                if "country" in data and "country_name" not in data:
                    # Simple mapping - in a real implementation, use a complete country code to name mapping
                    country_codes = {
                        "US": "United States", "GB": "United Kingdom", "CA": "Canada", "AU": "Australia",
                        "DE": "Germany", "FR": "France", "JP": "Japan", "CN": "China", "IN": "India",
                        "RU": "Russia", "BR": "Brazil", "IT": "Italy", "ES": "Spain", "NL": "Netherlands"
                    }
                    data["country_name"] = country_codes.get(data["country"], data["country"])
                return data
            else:
                print(f"IPInfo API error: {response.status_code}")
                return None
        except Exception as e:
            print(f"Error getting IPInfo data: {e}")
            return None
    
    def calculate_distance(self, lat1, lon1, lat2, lon2):
        """Calculate the distance between two sets of coordinates in kilometers using Haversine formula"""
        if None in (lat1, lon1, lat2, lon2):
            return None
            
        # Convert coordinates from degrees to radians
        lat1, lon1, lat2, lon2 = map(math.radians, [lat1, lon1, lat2, lon2])
        
        # Haversine formula
        dlon = lon2 - lon1
        dlat = lat2 - lat1
        a = math.sin(dlat/2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon/2)**2
        c = 2 * math.asin(math.sqrt(a))
        r = 6371  # Radius of Earth in kilometers
        
        return c * r
    
    def check_location_mismatch(self, local_info, public_info):
        """Compare locations of local and public IPs with detailed coordinates"""
        # Check if we have enough data to make a comparison
        if not local_info or not public_info:
            return False, "Insufficient location data for comparison"
        
        results = []
        
        # Calculate geographical distance if coordinates are available
        distance = None
        if all([local_info["latitude"], local_info["longitude"], public_info["latitude"], public_info["longitude"]]):
            distance = self.calculate_distance(
                local_info["latitude"], local_info["longitude"],
                public_info["latitude"], public_info["longitude"]
            )
            
            if distance is not None:
                results.append(f"Geographical distance: {distance:.2f} km")
                
                # Increase the threshold to reduce false positives
                # Many ISPs may show locations up to 100km away without VPN
                if distance > 100:  # Increased from 50km to 100km
                    results.append(f"Distance exceeds threshold (100 km), likely VPN")
        
        # Only consider it a VPN if we have a significant distance
        is_vpn = False
        if distance is not None:
            is_vpn = distance > 100  # More conservative threshold
        
        message = "; ".join(results) if results else "Locations match"
        return is_vpn, message
    
    def check_proxy_check_api(self, ip_address):
        """Check IP with ProxyCheck.io API"""
        if not self.proxy_check_api_key:
            return None, "No ProxyCheck API key provided"
        
        url = f"https://proxycheck.io/v2/{ip_address}?key={self.proxy_check_api_key}&vpn=1&asn=1"
        
        try:
            response = requests.get(url, timeout=5)
            if response.status_code == 200:
                data = response.json()
                
                if ip_address in data:
                    ip_data = data[ip_address]
                    
                    if "proxy" in ip_data and ip_data["proxy"] == "yes":
                        return True, f"Proxy detected by ProxyCheck: {ip_data.get('type', 'Unknown type')}"
                    
                    if "asn" in ip_data and "name" in ip_data["asn"]:
                        asn_name = ip_data["asn"]["name"].lower()
                        vpn_keywords = ["vpn", "tunnel", "proxy", "anonymous", "datacenter"]
                        if any(keyword in asn_name for keyword in vpn_keywords):
                            return True, f"VPN/Proxy ASN detected: {ip_data['asn']['name']}"
                
                return False, "No VPN indicators found by ProxyCheck"
            else:
                return None, f"ProxyCheck API error: {response.status_code}"
        except Exception as e:
            return None, f"Error checking ProxyCheck API: {e}"
    
    def check_vpnapi(self, ip_address):
        """Check IP with VPNAPI.io"""
        if not self.vpnapi_key:
            return None, "No VPNAPI key provided"
        
        url = f"https://vpnapi.io/api/{ip_address}?key={self.vpnapi_key}"
        
        try:
            response = requests.get(url, timeout=5)
            if response.status_code == 200:
                data = response.json()
                
                # Check for VPN, Proxy, or Tor
                security = data.get("security", {})
                vpn = security.get("vpn", False)
                proxy = security.get("proxy", False)
                tor = security.get("tor", False)
                
                if vpn:
                    return True, "VPN detected by VPNAPI"
                if proxy:
                    return True, "Proxy detected by VPNAPI"
                if tor:
                    return True, "Tor exit node detected by VPNAPI"
                
                return False, "No VPN indicators found by VPNAPI"
            else:
                return None, f"VPNAPI error: {response.status_code}"
        except Exception as e:
            return None, f"Error checking VPNAPI: {e}"
    
    def check_ipinfo_vpn_detection(self, ip_address, ip_data=None):
        """Check for VPN indicators using IPInfo data"""
        if not ip_data:
            ip_data = self.get_ipinfo_data(ip_address)
            
        if not ip_data:
            return None, "Could not retrieve IPInfo data"
        
        # Check for hosting/datacenter indicators
        if "company" in ip_data and "name" in ip_data["company"]:
            company_name = ip_data["company"]["name"].lower()
            suspicious_keywords = ["vpn", "proxy", "hosting", "cloud", "anonymous", "data center", 
                                  "datacenter", "server", "vps", "virtual", "tunnel", "secure"]
            if any(keyword in company_name for keyword in suspicious_keywords):
                return True, f"Suspicious company: {ip_data['company']['name']}"
        
        # Check for ASN that is known for VPN services
        if "asn" in ip_data:
            asn = ip_data.get("asn", "").split()[0]  # Extract ASN number
            if asn in self.known_vpn_asns:
                return True, f"Known VPN ASN: {asn}"
        
        # Check for discrepancies between country and timezone
        if "country" in ip_data and "timezone" in ip_data:
            timezone_parts = ip_data["timezone"].split("/")
            if len(timezone_parts) > 0:
                timezone_prefix = timezone_parts[0]
                country_timezone_map = {
                    "US": "America",
                    "GB": "Europe",
                    "CA": "America", 
                    "AU": "Australia",
                    "DE": "Europe",
                    "FR": "Europe",
                    "JP": "Asia",
                    "CN": "Asia",
                    "IN": "Asia",
                    "RU": ["Asia", "Europe"],  # Russia spans multiple continents
                    "BR": "America"
                }
                
                if ip_data["country"] in country_timezone_map:
                    expected_prefix = country_timezone_map[ip_data["country"]]
                    if isinstance(expected_prefix, list):
                        if timezone_prefix not in expected_prefix:
                            return True, f"Timezone mismatch: Country {ip_data['country']} with timezone {ip_data['timezone']}"
                    elif timezone_prefix != expected_prefix:
                        return True, f"Timezone mismatch: Country {ip_data['country']} with timezone {ip_data['timezone']}"
        
        # Check for privacy-focused hosting
        if "privacy" in ip_data and ip_data["privacy"]:
            return True, "Privacy-focused hosting detected"
            
        return False, "No VPN indicators found in IPInfo data"
    
    def check_dns_consistency(self, ip_address):
        """Check for DNS inconsistencies that might indicate VPN usage"""
        try:
            # Get hostname from IP
            hostname = socket.gethostbyaddr(ip_address)[0]
            
            # Check if hostname belongs to known VPN providers
            vpn_hostname_patterns = [
                r'.*vpn.*\..*',
                r'.*proxy.*\..*',
                r'.*tunnel.*\..*',
                r'.*pptp.*\..*',
                r'.*l2tp.*\..*',
                r'.*openvpn.*\..*',
                r'.*nordvpn.*\..*',
                r'.*expressvpn.*\..*',
                r'.*privatevpn.*\..*',
                r'.*cyberghost.*\..*',
                r'.*mullvad.*\..*',
                r'.*witopia.*\..*',
                r'.*purevpn.*\..*',
                r'.*ipvanish.*\..*',
                r'.*torguard.*\..*',
                r'.*surfshark.*\..*',
                r'.*protonvpn.*\..*',
                r'.*hide.*\..*',
                r'.*anonymous.*\..*',
                r'.*private.*\..*',
                r'.*secure.*\..*'
            ]
            
            for pattern in vpn_hostname_patterns:
                if re.match(pattern, hostname, re.IGNORECASE):
                    return True, f"VPN hostname pattern detected: {hostname}"
            
            # Check for dynamic/generic hostnames often used by VPNs
            dynamic_patterns = [
                r'.*node.*\..*',
                r'.*client.*\..*',
                r'.*dynamic.*\..*',
                r'.*pool.*\..*',
                r'^\d+[\.-]\d+[\.-]\d+[\.-]\d+\..*',  # IP-like hostnames
                r'.*static.*\..*'
            ]
            
            for pattern in dynamic_patterns:
                if re.match(pattern, hostname, re.IGNORECASE):
                    return True, f"Dynamic/generic hostname pattern detected: {hostname}"
            
            return False, "No VPN indicators found in DNS"
        except (socket.herror, socket.gaierror):
            return None, "Could not perform reverse DNS lookup"
        except Exception as e:
            return None, f"Error during DNS consistency check: {e}"
    
    def check_mtu_size(self):
        """Check MTU size which is often reduced when using a VPN"""
        try:
            # Get the default network interface
            if platform.system() == "Windows":
                # For Windows
                output = subprocess.check_output("netsh interface ipv4 show subinterfaces", shell=True)
                output = output.decode("utf-8")
                
                # Parse the output to find the MTU of the active interface
                lines = output.split('\n')
                for line in lines:
                    if "Connected" in line:
                        parts = line.split()
                        if len(parts) >= 4:
                            try:
                                mtu = int(parts[3])
                                # Standard Ethernet MTU is 1500
                                # Many VPNs use lower MTUs (1300-1450) to accommodate tunnel overhead
                                if mtu < 1470:
                                    return True, f"Reduced MTU detected: {mtu} (standard is 1500)"
                                else:
                                    return False, f"Normal MTU: {mtu}"
                            except (ValueError, IndexError):
                                pass
            else:
                # For Linux/Mac
                output = subprocess.check_output("ifconfig", shell=True)
                output = output.decode("utf-8")
                
                # Look for active interfaces and their MTU
                interfaces = output.split('\n\n')
                for interface in interfaces:
                    if "RUNNING" in interface and not "loop" in interface.lower():
                        mtu_match = re.search(r'mtu\s+(\d+)', interface, re.IGNORECASE)
                        if mtu_match:
                            mtu = int(mtu_match.group(1))
                            if mtu < 1470:
                                return True, f"Reduced MTU detected: {mtu} (standard is 1500)"
                            else:
                                return False, f"Normal MTU: {mtu}"
            
            return None, "Could not determine MTU size"
        except Exception as e:
            return None, f"Error checking MTU size: {e}"
    
    def check_webrtc_leak(self):
        """Check for WebRTC leaks that might reveal VPN usage"""
        # This is a simplified version - actual WebRTC checks would require browser interaction
        # For a command-line tool, we simulate this check
        try:
            local_ip = self.get_local_ip()
            public_ip = self.get_public_ip()
            
            # If local IP is a private IP, it's normal
            if ipaddress.ip_address(local_ip).is_private:
                # This is expected behavior - not indicative of a leak
                return False, "WebRTC would expose private IP (normal behavior)"
            
            # If local IP is public and differs from our public IP, it might be a WebRTC leak
            if local_ip != public_ip:
                return True, f"Potential WebRTC leak: Local IP {local_ip} differs from Public IP {public_ip}"
                
            return False, "No WebRTC leak indicators"
        except Exception as e:
            return None, f"Error checking WebRTC leak: {e}"
    
    def check_timing_analysis(self):
        """Perform timing analysis on network requests to detect VPN latency"""
        try:
            # Test servers in different regions
            test_servers = [
                "https://www.google.com",
                "https://www.amazon.com",
                "https://www.microsoft.com",
                "https://www.apple.com",
                "https://www.cloudflare.com"
            ]
            
            times = []
            for server in test_servers:
                start_time = time.time()
                try:
                    response = requests.get(server, timeout=5)
                    if response.status_code == 200:
                        end_time = time.time()
                        times.append(end_time - start_time)
                except Exception:
                    pass
            
            if not times:
                return None, "Could not complete timing analysis"
            
            avg_time = sum(times) / len(times)
            
            # VPNs typically add latency
            # This threshold can be adjusted based on normal network conditions
            if avg_time > 0.5:  # 500ms
                return True, f"High network latency detected: {avg_time:.3f}s avg. response time (typical of VPN)"
            else:
                return False, f"Normal network latency: {avg_time:.3f}s avg. response time"
        except Exception as e:
            return None, f"Error during timing analysis: {e}"
    
    def check_ssl_fingerprinting(self):
        """Check for SSL/TLS fingerprinting anomalies that might indicate VPN"""
        try:
            # Get the SSL/TLS context
            context = ssl.create_default_context()
            
            # Test connection to a popular site
            hostname = "www.google.com"
            with socket.create_connection((hostname, 443)) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    # Get the cipher and TLS version
                    cipher = ssock.cipher()
                    version = ssock.version()
                    
                    # VPNs often modify the cipher suite or use older TLS versions
                    # Check for less common cipher suites
                    uncommon_ciphers = [
                        "DHE-RSA", "DHE-DSS", "CAMELLIA", "SEED", "IDEA", "PSK", "SRP", "kGOST"
                    ]
                    
                    if any(uncommon in cipher[0] for uncommon in uncommon_ciphers):
                        return True, f"Uncommon SSL cipher detected: {cipher[0]}"
                    
                    # Check for older TLS versions (VPNs sometimes use older versions)
                    if version in ["TLSv1", "TLSv1.1"]:
                        return True, f"Older TLS version detected: {version}"
                    
                    return False, f"Normal SSL/TLS configuration: {cipher[0]}, {version}"
        except Exception as e:
            return None, f"Error during SSL fingerprinting: {e}"
    
    def check_interface_names(self):
        """Check for network interfaces with names typical of VPN software"""
        try:
            vpn_interface_patterns = [
                r'tun\d+',
                r'tap\d+',
                r'ppp\d+',
                r'ipsec\d*',
                r'vpn',
                r'nordvpn',
                r'ivpn',
                r'proton',
                r'mullvad',
                r'wg\d+',      # WireGuard
                r'utun\d+',    # Often used by VPNs on macOS
                r'ras\d+',     # Remote Access Service
                r'wwan\d+',    # Wireless WAN (sometimes used by VPNs)
                r'nordlynx'    # NordVPN's WireGuard implementation
            ]
            
            if platform.system() == "Windows":
                output = subprocess.check_output("ipconfig /all", shell=True)
            else:
                output = subprocess.check_output("ifconfig", shell=True)
            
            output = output.decode("utf-8")
            
            for pattern in vpn_interface_patterns:
                if re.search(pattern, output, re.IGNORECASE):
                    return True, f"VPN interface pattern detected: {pattern}"
            
            return False, "No VPN network interfaces detected"
        except Exception as e:
            return None, f"Error checking network interfaces: {e}"
    
    def check_open_vpn_ports(self, ip_address, timeout=1):
        """Scan for commonly used VPN ports"""
        # Note: Port scanning may not work against public IPs due to firewalls
        # and is more effective for local network scanning
        open_ports = []
        
        def check_port(port):
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(timeout)
            result = sock.connect_ex((ip_address, port))
            sock.close()
            if result == 0:
                return port
            return None
        
        # Collect all ports to scan
        ports_to_scan = []
        for protocol, ports in self.vpn_provider_ports.items():
            ports_to_scan.extend(ports)
        
        # Use threads for faster port scanning
        with ThreadPoolExecutor(max_workers=10) as executor:
            results = executor.map(check_port, ports_to_scan)
            
        for port in results:
            if port:
                open_ports.append(port)
                
        if open_ports:
            # Identify which VPN protocols might be in use
            protocols = []
            for protocol, ports in self.vpn_provider_ports.items():
                if any(port in open_ports for port in ports):
                    protocols.append(protocol)
                    
            return True, f"Open VPN ports detected: {open_ports}, possible protocols: {protocols}"
        return False, "No common VPN ports detected"
    
    def check_route_analysis(self):
        """Analyze network routes to detect VPN tunneling"""
        try:
            if platform.system() == "Windows":
                output = subprocess.check_output("route print", shell=True)
            else:
                output = subprocess.check_output("netstat -rn", shell=True)
            
            output = output.decode("utf-8")
            
            # Check for common VPN-related routing patterns
            vpn_route_patterns = [
                r'tun\d+',
                r'tap\d+',
                r'ppp\d+',
                r'10\.8\.\d+\.\d+',  # Common OpenVPN subnet
                r'10\.9\.\d+\.\d+',  # Common OpenVPN subnet
                r'100\.64\.\d+\.\d+', # Carrier-grade NAT sometimes used by VPNs
                r'192\.168\.9\.\d+',  # Common VPN subnet
                r'172\.16\.\d+\.\d+/\d+', # Private subnet often used by VPNs
                r'fd\w{2}:', # IPv6 ULA addresses often used by VPNs
            ]
            
            for pattern in vpn_route_patterns:
                if re.search(pattern, output):
                    return True, f"VPN routing pattern detected: {pattern}"
            
            return False, "No VPN routing patterns detected"
        except Exception as e:
            return None, f"Error analyzing network routes: {e}"
    
    def check_vpn_processes(self):
        """Check for running VPN-related processes"""
        try:
            vpn_process_names = [
                "openvpn", "nordvpn", "expressvpn", "ivpn", "protonvpn", 
                "mullvad", "wireguard", "wg", "tunnelblick", "viscosity",
                "surfshark", "cyberghost", "privatevpn", "ipvanish", "purevpn",
                "vyprvpn", "windscribe", "strongvpn", "privatetunnel", "hotspotshield",
                "safervpn", "tunnelbear", "avast", "norton", "kaspersky",
                "pia", "private internet access", "torguard", "hidemyass", "vpnunlimited",
                "zenmate", "avira", "betternet", "f-secure", "freedome",
                "hideme", "hideman", "astrill", "buffer", "celo",
                "disconnected", "faceless", "finch", "ironsocket", "kepard",
                "saferweb", "ultravpn", "vpnsecure", "zoog"
            ]
            
            if platform.system() == "Windows":
                output = subprocess.check_output("tasklist", shell=True)
            else:
                output = subprocess.check_output("ps aux", shell=True)
            
            output = output.decode("utf-8").lower()
            
            for process in vpn_process_names:
                if process.lower() in output:
                    return True, f"VPN process detected: {process}"
            
            return False, "No VPN processes detected"
        except Exception as e:
            return None, f"Error checking for VPN processes: {e}"
    
    def detect_vpn(self):
        """Perform comprehensive VPN detection with detailed location data"""
        results = []
        
        # Get both IP addresses
        local_ip = self.get_local_ip()
        public_ip = self.get_public_ip()
        
        if not local_ip or not public_ip:
            return {
                "error": "Could not determine both local and public IP addresses",
                "vpn_detected": None,
                "confidence": 0,
                "timestamp": time.time()
            }
        
        # Get detailed location data for both IPs
        local_location = self.get_location_data(local_ip, is_local=True)
        public_location = self.get_location_data(public_ip, is_local=False)
        
        # PRIMARY METHOD: Location comparison
        is_location_mismatch, location_message = self.check_location_mismatch(local_location, public_location)
        location_weight = 50  # This test gets 50% of the total weight
        results.append({
            "test": "Location Comparison (PRIMARY)",
            "detected": is_location_mismatch,
            "details": location_message,
            "weight": location_weight
        })
        
        # SECONDARY METHODS: API-based checks
        # Check with ProxyCheck API
        proxy_check_result, proxy_check_message = self.check_proxy_check_api(public_ip)
        results.append({
            "test": "ProxyCheck API",
            "detected": proxy_check_result,
            "details": proxy_check_message,
            "weight": 10
        })
        
        # Check with VPNAPI
        vpnapi_result, vpnapi_message = self.check_vpnapi(public_ip)
        results.append({
            "test": "VPNAPI Service",
            "detected": vpnapi_result,
            "details": vpnapi_message,
            "weight": 10
        })
        
        # Check IPInfo for VPN indicators
        ipinfo_result, ipinfo_message = self.check_ipinfo_vpn_detection(public_ip)
        results.append({
            "test": "IPInfo Analysis",
            "detected": ipinfo_result,
            "details": ipinfo_message,
            "weight": 5
        })

        # Check against known VPN IP databases
        known_vpn_result, known_vpn_message = self.check_known_vpn_ip(public_ip)
        results.append({
            "test": "Known VPN IP Database",
            "detected": known_vpn_result,
            "details": known_vpn_message,
            "weight": 8
        })

        # Check for datacenter/hosting IP (common for VPNs)
        datacenter_result, datacenter_message = self.check_datacenter_ip(public_ip)
        results.append({
            "test": "Datacenter IP Check",
            "detected": datacenter_result,
            "details": datacenter_message,
            "weight": 5
        })

        # Check for timezone mismatch
        timezone_result, timezone_message = self.check_timezone_mismatch()
        results.append({
            "test": "Timezone Mismatch",
            "detected": timezone_result,
            "details": timezone_message,
            "weight": 4
        })
        
        # ADDITIONAL METHODS
        # Check for DNS inconsistencies
        dns_result, dns_message = self.check_dns_consistency(public_ip)
        results.append({
            "test": "DNS Consistency Check",
            "detected": dns_result,
            "details": dns_message,
            "weight": 3
        })
        
        # Check MTU size
        mtu_result, mtu_message = self.check_mtu_size()
        results.append({
            "test": "MTU Size Analysis",
            "detected": mtu_result,
            "details": mtu_message,
            "weight": 3
        })
        
        # Check for WebRTC leaks
        webrtc_result, webrtc_message = self.check_webrtc_leak()
        results.append({
            "test": "WebRTC Leak Test",
            "detected": webrtc_result,
            "details": webrtc_message,
            "weight": 3
        })
        
        # Perform timing analysis
        timing_result, timing_message = self.check_timing_analysis()
        results.append({
            "test": "Network Timing Analysis",
            "detected": timing_result,
            "details": timing_message,
            "weight": 3
        })
        
        # Check SSL/TLS fingerprinting
        ssl_result, ssl_message = self.check_ssl_fingerprinting()
        results.append({
            "test": "SSL/TLS Fingerprinting",
            "detected": ssl_result,
            "details": ssl_message,
            "weight": 3
        })
        
        # Check network interface names
        interface_result, interface_message = self.check_interface_names()
        results.append({
            "test": "Network Interface Analysis",
            "detected": interface_result,
            "details": interface_message,
            "weight": 3
        })
        
        # Analyze network routes
        route_result, route_message = self.check_route_analysis()
        results.append({
            "test": "Network Route Analysis",
            "detected": route_result,
            "details": route_message,
            "weight": 3
        })
        
        # Check for VPN processes
        process_result, process_message = self.check_vpn_processes()
        results.append({
            "test": "VPN Process Detection",
            "detected": process_result,
            "details": process_message,
            "weight": 4
        })
        
        # Calculate weighted confidence score
        confidence = self.calculate_weighted_confidence(results)
        
        # IMPROVED: Much more conservative VPN detection logic
        direct_vpn_indicators = [
            process_result,                # VPN processes running
            interface_result,              # VPN interfaces detected
            route_result,                  # VPN routing patterns
        ]

        api_vpn_indicators = [
            proxy_check_result,            # ProxyCheck API reported VPN
            vpnapi_result,                 # VPNAPI reported VPN
            ipinfo_result                  # IPInfo reported VPN
        ]

        # More stringent criteria to reduce false positives:
        # 1. Direct indicators are most reliable - processes, interfaces, routes
        # 2. API indicators need stronger agreement (at least 2 positive)
        # 3. Location mismatch alone is not enough - need confirming evidence

        if any(indicator is True for indicator in direct_vpn_indicators):
            # System-level evidence is strongest
            vpn_detected = True
        elif sum(1 for indicator in api_vpn_indicators if indicator is True) >= 2:
            # At least 2 APIs must agree
            vpn_detected = True 
        elif is_location_mismatch is True and mtu_result is True:
            # Location mismatch AND MTU change is good evidence
            vpn_detected = True
        else:
            # In all other cases, assume no VPN
            vpn_detected = False
        
        return {
            "local_ip": local_ip,
            "public_ip": public_ip,
            "local_location": local_location,
            "public_location": public_location,
            "vpn_detected": vpn_detected,
            "confidence": confidence,
            "tests": results,
            "timestamp": time.time()
        }
    
    def calculate_weighted_confidence(self, results):
        """Calculate weighted confidence score based on test results"""
        total_weight = 0
        weighted_positive = 0
        
        for result in results:
            if result["detected"] is not None:
                weight = result.get("weight", 1)
                total_weight += weight
                
                if result["detected"] is True:
                    weighted_positive += weight
        
        if total_weight == 0:
            return 0
        
        return (weighted_positive / total_weight) * 100

    def load_known_vpn_ips(self):
        """Load a database of known VPN IPs from a reliable source"""
        vpn_list_url = "https://raw.githubusercontent.com/X4BNet/lists_vpn/main/output/vpn/ipv4.txt"
        known_vpns = set()
        
        try:
            response = requests.get(vpn_list_url, timeout=5)
            if response.status_code == 200:
                known_vpns = set(response.text.splitlines())
                return known_vpns
        except Exception as e:
            print(f"Could not load VPN IP database: {e}")
        
        # Fallback to some known VPN ranges
        return {
            "185.152.32.0/22", "45.89.228.0/22", "193.151.128.0/19",
            "10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16"
        }

    def check_known_vpn_ip(self, ip_address):
        """Check if IP is in known VPN database"""
        try:
            vpn_ips = self.load_known_vpn_ips()
            if ip_address in vpn_ips:
                return True, f"IP found in known VPN database"
            
            # Check CIDR ranges
            ip = ipaddress.ip_address(ip_address)
            for range_str in vpn_ips:
                if '/' in range_str:  # CIDR notation
                    try:
                        network = ipaddress.ip_network(range_str)
                        if ip in network:
                            return True, f"IP in known VPN range: {range_str}"
                    except:
                        continue
            
            return False, "IP not found in known VPN database"
        except Exception as e:
            return None, f"Error checking VPN database: {e}"

    def check_timezone_mismatch(self):
        """Check if system timezone matches IP geolocation timezone"""
        try:
            ip_geo = self.get_ipinfo_data(self.get_public_ip())
            if not ip_geo or 'timezone' not in ip_geo:
                return None, "Could not determine IP timezone"
            
            ip_tz = ip_geo.get('timezone', '')
            system_tz = datetime.now().astimezone().tzname()
            
            # Compare timezones, allowing for minor differences
            if ip_tz and system_tz and ip_tz != system_tz:
                return True, f"Timezone mismatch: System={system_tz}, IP={ip_tz}"
            
            return False, "Timezone matches between system and IP geolocation"
        except Exception as e:
            return None, f"Error checking timezone: {e}"

    def check_datacenter_ip(self, ip_address):
        """Check if IP belongs to a datacenter (common for VPNs)"""
        try:
            ip_data = self.get_ipinfo_data(ip_address)
            if not ip_data or 'org' not in ip_data:
                return None, "Could not determine IP organization"
                
            org = ip_data.get('org', '').lower()
            isp = ip_data.get('isp', '').lower()
            
            datacenter_keywords = [
                'amazon', 'aws', 'digital ocean', 'azure', 'google cloud', 
                'linode', 'vultr', 'ovh', 'hostwinds', 'rackspace', 'softlayer',
                'hosting', 'host', 'datacenter', 'data center', 'dedicated', 
                'server', 'vps', 'cloud'
            ]
            
            for keyword in datacenter_keywords:
                if keyword in org or keyword in isp:
                    return True, f"IP belongs to datacenter/hosting provider: {org}"
            
            return False, "IP does not belong to common datacenter/hosting provider"
        except Exception as e:
            return None, f"Error checking datacenter IP: {e}"

if __name__ == "__main__":
    # Initialize with your API keys
    detector = EnhancedVPNDetector(
        proxy_check_api_key="n2g051-435450-9661v0-x64j46",
        vpnapi_key="03d50e96cfed4eeca7f4a5308b3262d6",
        ipinfo_api_key="889bf0bc1000a4"
    )
    
    print("Running VPN detection (this may take a moment)...")
    full_result = detector.detect_vpn()
    
    # Check for proxy detection
    proxy_detected = any("Proxy" in test["test"] and test["detected"] is True for test in full_result["tests"])
    
    # Apply 30% threshold and consider proxy detection
    confidence_value = float(full_result["confidence"])
    vpn_status = "Connected" if (confidence_value >= 30.0 or proxy_detected) else "Disconnected"
    
    # Create reorganized output with three sections
    simplified_output = {
        "VPN status": {
            "vpn_status": vpn_status
        },
        "Public IP": {
            "public_ip": full_result["public_ip"],
            "public_location": f"{full_result['public_location']['city'] or 'Unknown'}, {full_result['public_location']['region'] or 'Unknown'}, {full_result['public_location']['country'] or 'Unknown'}",
            "coordinates": {
                "latitude": full_result["public_location"]["latitude"],
                "longitude": full_result["public_location"]["longitude"]
            },
            "isp": full_result["public_location"]["org"] or "Unknown",
            "proxy_detected": proxy_detected,
            "confidence": f"{confidence_value:.1f}%"
        },
        "Local IP": {
            "local_ip": full_result["local_ip"],
            "local_location": f"{full_result['local_location']['city'] or 'Unknown'}, {full_result['local_location']['region'] or 'Unknown'}, {full_result['local_location']['country'] or 'Unknown'}",
            "os_type": platform.system() + " " + platform.release()
        }
    }
    
    # Print simplified output
    print(json.dumps(simplified_output, indent=2))

#vpn_blocking.py

#!/usr/bin/env python3
"""
VPN Detection and Blocking Tool

This script implements various techniques to detect and block VPN connections
on both Windows and Linux systems without disrupting general internet access.
"""

import os
import platform
import subprocess
import logging
import tempfile
import sys
import socket
import ipaddress
import time
import threading
import requests
import json
import re
from datetime import datetime, timedelta
import atexit
import signal
import re

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler(os.path.join(tempfile.gettempdir(), "vpn_blocker.log")),
        logging.StreamHandler()
    ]
)

# Try to import optional modules
NETIFACES_AVAILABLE = False
try:
    import netifaces
    NETIFACES_AVAILABLE = True
except ImportError:
    logging.warning("netifaces module not available - some detection features limited")
    # Implement fallback for network interfaces detection
    def get_network_interfaces():
        """Fallback implementation when netifaces is not available"""
        interfaces = []
        try:
            if platform.system() == "Windows":
                # Windows fallback using ipconfig
                output = subprocess.check_output("ipconfig /all", shell=True, universal_newlines=True)
                current_iface = None
                for line in output.split('\n'):
                    if "adapter" in line.lower() and ":" in line:
                        current_iface = line.split(":")[0].strip()
                        interfaces.append(current_iface)
            else:
                # Linux fallback using /proc/net/dev
                with open('/proc/net/dev', 'r') as f:
                    for line in f:
                        if ':' in line:
                            iface = line.split(':')[0].strip()
                            if iface != 'lo' and not iface.startswith('docker'):
                                interfaces.append(iface)
            return interfaces
        except Exception as e:
            logging.error(f"Error in fallback interface detection: {e}")
            return []

try:
    from scapy.all import IP, TCP, UDP, sniff
    SCAPY_AVAILABLE = True
except ImportError:
    SCAPY_AVAILABLE = False
    logging.warning("scapy module not available - traffic analysis features limited")

# Common variables for VPN blocking configuration
CONFIG_FILE = "vpn_blocker_config.json"
UPDATE_INTERVAL = timedelta(hours=24)  # Update IP ranges every 24 hours

# Windows-specific VPN blocking configuration
VPN_PORTS = [1194, 500, 4500, 1701, 1723, 51820, 443]  # Ports used by VPN connections
VPN_PROTOCOLS = ["UDP", "TCP"]
VPN_PROTOCOL_NUMBERS = {
    "GRE": 47,  # Generic Routing Encapsulation (PPTP)
    "ESP": 50,  # Encapsulating Security Payload (IPsec)
    "AH": 51,   # Authentication Header (IPsec)
}
VPN_PROCESSES = [
    "openvpn.exe",
    "nordvpn.exe",
    "expressvpn.exe",
    "protonvpn.exe",
    "ipsec.exe",
    "softether.exe",
    "wireguard.exe",
]
VPN_DOMAINS = [
    "nordvpn.com",
    "expressvpn.com",
    "protonvpn.com",
    "surfshark.com",
    "cyberghostvpn.com",
    "pia.com",
    "privateinternetaccess.com",
    "mullvad.net",
    "vyprvpn.com",
    "torguard.net",
    "purevpn.com",
    "ipvanish.com",
    "tunnelbear.com",
    "windscribe.com",
    "hidemyass.com",
    "cyberghostvpn.com",
    "strongvpn.com",
]

# VPN Service Lists (Platform Specific)
VPN_SERVICES = {
    "Linux": [
        "openvpn", "strongswan", "xl2tpd", "ppp", "pptp", "l2tp", "ipsec", "wireguard",
        "nordvpn", "expressvpn", "protonvpn", "mullvad", "vyprvpn", "surfshark", "cisco anyconnect", "softether",
        "windscribe", "tunnelbear", "ipvanish", "privatevpn", "goldenfrog", "hide.me", "cyberghost", "privateinternetaccess"
    ],
    "Windows": [
        "OpenVPNService", "OpenVPNServiceInteractive", "OpenVPNServiceLegacy",
        "nordvpn-service", "ExpressVPNService", "ProtonVPN Service", "SurfsharkService",
        "CyberGhost Service", "vyprVPNService", "WindscribeService", "MullvadVPN",
        "PureVPNService", "ipvanish", "HideMyAssService", "TorGuardService",
        "PrivateTunnelService", "StrongVPNService", "IVPN Client", "AirVPN",
        "BlackVPN", "VPNSecureService", "SaferVPNService", "TunnelBearService",
        "AvastVPNService", "HSS Service", "BetternetService", "UltraSurfService",
        "PsiphonService", "LanternService", "AVG VPN", "Avira Phantom VPN",
        "Kaspersky VPN", "Norton VPN", "McAfee VPN", "Bitdefender VPN",
        
        # Enterprise VPN Services
        "Cisco AnyConnect Secure Mobility Agent", "vpnagent", "FortiClient",
        "FortiSSLVPNdaemon", "CheckPointVPN", "PulseSecureService", "F5VPN",
        "SonicWallVPN", "GlobalProtect", "ZeroTierOne", "WireGuardTunnel",
        "WireGuardManager", "PritunlService", "Viscosity", "sstp-service",
        "TailscaleService", "CloudflareWARP", "Stunnel", "ShadowsocksService",
        "V2RayService", "XRayService", "TrojanService", "ClashService",
        "OutlineService", "SoftEtherVPN", "SoftEther VPN Client",
        "LogMeIn Hamachi Tunneling Engine",
        
        # Windows Built-in VPN and Network Services to disable
        "RasMan", "SstpSvc", "SwisscomVPNService", "VPNService", "RemoteAccess", 
        "IKEEXT", "PolicyAgent", "iphlpsvc", "SharedAccess", "mpssvc", 
        "PptpMiniport", "RasAcd", "RasAuto", "Rasl2tp", "RasPppoe", 
        "RasSstp", "RemoteAccess", "SstpSvc", "WinRM"
    ]
}

# VPN Provider data with multiple blocking attributes
VPN_PROVIDERS_EXTENDED = {
    'expressvpn': [
        {
            'ip': '185.59.220.100',
            'ip_range': '185.59.220.0/24',
            'hostname': 'us-new-york-01.vpn.expressvpn.com',
            'port': 443, 'proto': 'tcp',
            'ssl_fingerprint': '4F:65:...',
            'http_user_agent': 'Mozilla/5.0 (compatible; ExpressVPN)',
            'dns_name_pattern': r'.*expressvpn\.com',
            'asn_number': 36352,
            'known_vpn_domains': ['vpn.expressvpn.com', 'router.expressvpn.com'],
        },
    ],
    'nordvpn': [
        {
            'ip': '89.187.162.115',
            'ip_range': '89.187.162.0/24',
            'hostname': 'us2350.nordvpn.com',
            'port': 1194, 'proto': 'udp',
            'ssl_fingerprint': '12:34:...',
            'http_user_agent': 'Mozilla/5.0 (compatible; NordVPN)',
            'dns_name_pattern': r'.*nordvpn\.com',
            'asn_number': 60068,
            'known_vpn_domains': ['us2350.nordvpn.com', 'api.nordvpn.com'],
        },
    ],
    'protonvpn': [
        {
            'ip': '185.159.159.110',
            'hostname': 'us-01.protonvpn.net',
            'port': 1195, 'proto': 'udp',
            'ssl_fingerprint': '67:89:...',
            'http_user_agent': 'Mozilla/5.0 (compatible; ProtonVPN)',
            'dns_name_pattern': r'.*protonvpn\.(net|com)',
            'asn_number': 21046,
            'known_vpn_domains': ['us-01.protonvpn.net', 'protonvpn.net'],
        },
    ],
}

# Additional CIDR list for known VPN ranges
KNOWN_VPN_CIDRS = [
    # NordVPN
    "45.83.220.0/24", "81.95.231.0/24", "84.17.50.0/24", "84.17.51.0/24",
    "84.17.59.0/24", "86.105.213.0/24", "89.187.179.0/24", "103.107.198.0/24",
    "109.201.133.0/24", "185.128.24.0/24", "185.200.116.0/22", "185.213.155.0/24",
    "185.253.96.0/22", "193.32.246.0/24", "194.35.233.0/24",

    # ExpressVPN
    "77.111.240.0/21", "77.111.245.0/24", "77.111.246.0/23", "91.194.90.0/23",
    "103.172.92.0/23", "149.12.112.0/24", "185.104.184.0/22", "185.220.100.0/22",
    "193.27.14.0/24",

    # Surfshark
    "37.19.214.0/23", "45.132.244.0/22", "45.140.36.0/22", "64.137.32.0/21",
    "89.187.186.0/23", "91.199.116.0/22", "146.70.32.0/21", "146.70.80.0/21",
    "160.153.130.0/23", "193.47.80.0/22",

    # Private Internet Access (PIA)
    "37.120.128.0/18", "37.120.192.0/20", "37.120.208.0/21", "93.179.64.0/20",
    "185.94.52.0/22", "192.240.146.0/24", "209.222.0.0/21",

    # CyberGhost
    "37.48.64.0/19", "84.17.32.0/20", "88.218.16.0/20", "185.156.172.0/22",
    "185.206.224.0/22", "194.187.248.0/22",

    # Mullvad
    "193.138.218.0/23", "185.213.154.0/24", "45.83.221.0/24", "193.23.244.0/23",
    "185.65.134.0/23",
]

# VPN port/protocol combinations
VPN_PORTS_PROTOCOLS_EXTENDED = [
    {"protocol": "udp", "port": "1194"},  # OpenVPN
    {"protocol": "tcp", "port": "1194"},
    {"protocol": "udp", "port": "51820"},  # WireGuard
    {"protocol": "udp", "port": "500"},    # IPSec/IKEv2
    {"protocol": "udp", "port": "4500"},
    {"protocol": "udp", "port": "1701"},   # L2TP
    {"protocol": "tcp", "port": "1723"},   # PPTP
    {"protocol": "gre"},                   # GRE Protocol (used by PPTP)
]

# iptables chain names for VPN blocking
CHAIN_NAME_IP = "BLOCK_VPN_IP"
CHAIN_NAME_HTTP = "BLOCK_VPN_HTTP" 
CHAIN_NAME_DNS = "BLOCK_VPN_DNS"
IPTABLES_CHAIN = "VPN_BLOCK"

def _ensure_clean_exit():
    """Ensure the application exits cleanly."""
    try:
        import os
        os._exit(0)
    except Exception as e:
        print(f"Error during clean exit: {e}")


class VPNBlocker:
    """Class for VPN detection and blocking operations"""
    
    def __init__(self, callback=None):
        """Initialize VPN Blocker
        
        Args:
            callback: Function to call with status updates
        """
        self.os_type = platform.system()
        self.block_id = datetime.now().strftime("%Y%m%d%H%M%S")
        self.blocked_ips = set()
        self.known_vpn_ips = set()
        self.callback = callback
        self.blocking_thread = None
        
    def start_blocking(self):
        """Start blocking VPN connections"""
        self.blocking_thread = threading.Thread(target=self._run_blocking)
        self.blocking_thread.daemon = True
        self.blocking_thread.start()
        
    def stop_blocking(self):
        """Stop blocking VPN connections"""
        self.blocking_thread = threading.Thread(target=self._run_unblocking)
        self.blocking_thread.daemon = True
        self.blocking_thread.start()
    
    def _run_blocking(self):
        """Run the blocking operation in a thread"""
        result = {"success": False, "message": "Unknown error"}
        
        try:
            if self.os_type == "Windows":
                result = self.block_vpn_windows()
            elif self.os_type == "Linux":
                result = self.block_vpn_linux()
            else:
                result = {"success": False, "message": f"VPN blocking not supported on {self.os_type}"}
        except Exception as e:
            result = {"success": False, "message": f"Error: {str(e)}"}
            
        if self.callback:
            self.callback(result)
    
    def _run_unblocking(self):
        """Run the unblocking operation in a thread"""
        result = {"success": False, "message": "Unknown error"}
        
        try:
            if self.os_type == "Windows":
                result = self.stop_blocking_windows()
            elif self.os_type == "Linux":
                result = self.stop_blocking_linux()
            else:
                result = {"success": False, "message": f"VPN blocking not supported on {self.os_type}"}
        except Exception as e:
            result = {"success": False, "message": f"Error: {str(e)}"}
            
        if self.callback:
            self.callback(result)
    
    def load_known_vpn_ranges(self):
        """Load known VPN IP ranges from public sources"""
        try:
            response = requests.get("https://raw.githubusercontent.com/X4BNet/lists_vpn/main/output/vpn/ipv4.txt", timeout=10)
            if response.status_code == 200:
                vpn_ips = response.text.strip().split('\n')
                for ip in vpn_ips:
                    if ip and not ip.startswith('#'):
                        self.known_vpn_ips.add(ip.strip())
                logging.info(f"Loaded {len(self.known_vpn_ips)} known VPN IP addresses")
            return True
        except Exception as e:
            logging.error(f"Error loading VPN database: {e}")
            return False
    
    def check_connection_against_known_vpns(self, ip_address):
        """Check if an IP belongs to a known VPN provider"""
        if not self.known_vpn_ips:
            self.load_known_vpn_ranges()
            
        if ip_address in self.known_vpn_ips:
            return True
        
        for vpn_ip in self.known_vpn_ips:
            if '/' in vpn_ip:  # It's a CIDR notation
                try:
                    if ipaddress.ip_address(ip_address) in ipaddress.ip_network(vpn_ip):
                        return True
                except ValueError:
                    pass
        
        return False
    
    def detect_vpn_by_dns_leak(self):
        """Detect potential VPN usage through DNS leak testing"""
        detected_vpns = []
        
        try:
            # Get the system's DNS servers
            if self.os_type == "Windows":
                output = subprocess.check_output('ipconfig /all', shell=True).decode('utf-8')
                dns_servers = []
                for line in output.split('\n'):
                    if 'DNS Servers' in line:
                        dns_ip = line.split(':')[-1].strip()
                        if dns_ip:
                            dns_servers.append(dns_ip)
            else:  # Linux
                dns_servers = []
                if os.path.exists('/etc/resolv.conf'):
                    with open('/etc/resolv.conf', 'r') as f:
                        for line in f:
                            if line.startswith('nameserver'):
                                dns_servers.append(line.split()[1])
            
            # Check for common VPN DNS servers
            vpn_dns_indicators = ['8.8.8.8', '1.1.1.1', '208.67.222.222']
            
            for dns in dns_servers:
                if dns in vpn_dns_indicators or self.check_connection_against_known_vpns(dns):
                    detected_vpns.append(("DNS Server", dns))
            
            return detected_vpns
        except Exception as e:
            logging.error(f"DNS leak detection error: {e}")
            return []
    
    def detect_vpn_by_port_scan(self):
        """Detect active VPN connections by checking common VPN ports"""
        detected_vpns = []
        
        try:
            if self.os_type == "Windows":
                result = subprocess.check_output('netstat -ano', shell=True).decode('utf-8')
                for line in result.split('\n'):
                    for port in VPN_PORTS:
                        if f':{port}' in line and 'ESTABLISHED' in line:
                            parts = line.split()
                            if len(parts) >= 3:
                                remote = parts[2]
                                ip = remote.split(':')[0]
                                detected_vpns.append(("Active Connection", ip))
            else:
                try:
                    result = subprocess.check_output('ss -tuln', shell=True, stderr=subprocess.DEVNULL).decode('utf-8')
                    for line in result.split('\n'):
                        for port in VPN_PORTS:
                            if f':{port}' in line:
                                parts = line.split()
                                if len(parts) >= 5:
                                    addr = parts[4]
                                    ip = addr.split(':')[0]
                                    detected_vpns.append(("Listening Service", ip))
                except subprocess.CalledProcessError:
                    # Fallback if ss fails
                    result = subprocess.check_output('netstat -tuln', shell=True, stderr=subprocess.DEVNULL).decode('utf-8')
                    for line in result.split('\n'):
                        for port in VPN_PORTS:
                            if f':{port}' in line:
                                parts = line.split()
                                if len(parts) >= 4:
                                    addr = parts[3]
                                    ip = addr.split(':')[0]
                                    detected_vpns.append(("Listening Service", ip))
            
            return detected_vpns
        except Exception as e:
            logging.error(f"Port scan detection error: {e}")
            return []
    
    def analyze_network_traffic(self, packet_count=100):
        """Analyze network traffic patterns to detect VPN usage"""
        detected_vpns = []
        
        if not SCAPY_AVAILABLE:
            logging.warning("Network traffic analysis skipped - scapy module not available")
            return []
        
        def packet_callback(packet):
            if IP in packet:
                ip_src = packet[IP].src
                ip_dst = packet[IP].dst
                
                # Check against known VPN IPs
                if self.check_connection_against_known_vpns(ip_dst):
                    detected_vpns.append(("Traffic Analysis", ip_dst))
                
                # Check for VPN ports
                if UDP in packet and packet[UDP].dport in VPN_PORTS:
                    detected_vpns.append(("VPN Port Traffic", ip_dst))
                
                if TCP in packet and packet[TCP].dport in VPN_PORTS:
                    detected_vpns.append(("VPN Port Traffic", ip_dst))
        
        try:
            # Sniff packets for a short period
            sniff(prn=packet_callback, count=packet_count, timeout=5)
            return detected_vpns
        except Exception as e:
            logging.error(f"Traffic analysis error: {e}")
            return []

    def check_vpn_process_names(self):
        """Check for running processes with VPN-related names"""
        vpn_process_indicators = [
            "openvpn", "vpn", "wireguard", "nordvpn", "expressvpn", "surfshark",
            "privatevpn", "protonvpn", "mullvad", "ipvanish", "purevpn", "ivpn"
        ]
        
        detected_vpns = []
        
        try:
            if self.os_type == "Windows":
                result = subprocess.check_output('tasklist', shell=True).decode('utf-8')
                for line in result.split('\n'):
                    for indicator in vpn_process_indicators:
                        if indicator.lower() in line.lower():
                            detected_vpns.append(("VPN Process", indicator))
            else:
                result = subprocess.check_output('ps aux', shell=True).decode('utf-8')
                for line in result.split('\n'):
                    for indicator in vpn_process_indicators:
                        if indicator.lower() in line.lower():
                            detected_vpns.append(("VPN Process", indicator))
            
            return detected_vpns
        except Exception as e:
            logging.error(f"Process check error: {e}")
            return []

    def detect_vpn_interfaces(self):
        """Detect VPN interfaces without relying on netifaces"""
        detected_vpns = []
        
        try:
            if self.os_type == "Windows":
                # Use Windows-specific commands
                output = subprocess.check_output("ipconfig /all", shell=True, universal_newlines=True)
                
                # Look for adapter descriptions or names containing VPN-related terms
                vpn_keywords = ["vpn", "virtual", "tunnel", "tap", "nordvpn", "express", 
                               "proton", "surfshark", "mullvad", "wireguard", "openvpn"]
                
                for line in output.split('\n'):
                    if "adapter" in line.lower():
                        adapter_name = line.split(':')[0].strip()
                        if any(keyword in adapter_name.lower() for keyword in vpn_keywords):
                            detected_vpns.append(("VPN Interface", adapter_name))
                    
                    # Also check if any of the descriptions contain VPN keywords
                    if "description" in line.lower():
                        description = line.split(':')[1].strip()
                        if any(keyword in description.lower() for keyword in vpn_keywords):
                            detected_vpns.append(("VPN Description", description))
            else:
                # Linux-specific approach
                # Check for tun/tap interfaces
                try:
                    if os.path.exists('/proc/net/dev'):
                        with open('/proc/net/dev', 'r') as f:
                            for line in f:
                                if ':' in line:
                                    iface = line.split(':')[0].strip()
                                    if iface.startswith(('tun', 'tap', 'ppp', 'vpn')):
                                        detected_vpns.append(("VPN Interface", iface))
                except Exception as e:
                    logging.error(f"Error checking network interfaces: {e}")
                    
                # Also check loaded kernel modules
                try:
                    output = subprocess.check_output("lsmod", shell=True, universal_newlines=True)
                    vpn_modules = ["tun", "tap", "ppp_generic", "wireguard"]
                    for line in output.split('\n'):
                        parts = line.split()
                        if parts and parts[0] in vpn_modules:
                            detected_vpns.append(("VPN Module", parts[0]))
                except Exception:
                    pass
            
            return detected_vpns
        except Exception as e:
            logging.error(f"Error in VPN interface detection: {e}")
            return []

    def block_ip(self, ip_address):
        """Block an IP address using the system firewall"""
        if ip_address in self.blocked_ips:
            return True  # Already blocked
        
        try:
            if self.os_type == "Windows":
                command = f'netsh advfirewall firewall add rule name="BlockVPN-{ip_address}" dir=out action=block remoteip={ip_address}'
            else:  # Linux
                command = f'iptables -A OUTPUT -d {ip_address} -j DROP'
            
            process = subprocess.run(command, shell=True, capture_output=True, text=True)
            success = process.returncode == 0
            
            if success:
                self.blocked_ips.add(ip_address)
                logging.info(f"Blocked VPN IP: {ip_address}")
                
                # Schedule unblock after 1 hour
                def delayed_unblock():
                    time.sleep(3600)  # 1 hour
                    self.unblock_ip(ip_address)
                
                threading.Thread(target=delayed_unblock, daemon=True).start()
            
            return success
        except Exception as e:
            logging.error(f"Error blocking IP {ip_address}: {e}")
            return False
    
    def unblock_ip(self, ip_address):
        """Unblock a previously blocked IP address"""
        if ip_address not in self.blocked_ips:
            return True  # Not blocked
        
        try:
            if self.os_type == "Windows":
                command = f'netsh advfirewall firewall delete rule name="BlockVPN-{ip_address}"'
            else:  # Linux
                command = f'iptables -D OUTPUT -d {ip_address} -j DROP'
            
            process = subprocess.run(command, shell=True, capture_output=True, text=True)
            success = process.returncode == 0
            
            if success:
                self.blocked_ips.remove(ip_address)
                logging.info(f"Unblocked VPN IP: {ip_address}")
            
            return success
        except Exception as e:
            logging.error(f"Error unblocking IP {ip_address}: {e}")
            return False
    
    def get_current_connections(self):
        """Get a list of all current network connections"""
        connections = []
        
        try:
            if self.os_type == "Windows":
                result = subprocess.check_output('netstat -ano', shell=True).decode('utf-8')
                for line in result.split('\n'):
                    if 'ESTABLISHED' in line:
                        parts = line.split()
                        if len(parts) >= 3:
                            remote = parts[2]
                            ip = remote.split(':')[0]
                            if not self.is_private_ip(ip):
                                connections.append(ip)
            else:
                try:
                    result = subprocess.check_output('ss -tn state established', shell=True, stderr=subprocess.DEVNULL).decode('utf-8')
                    for line in result.split('\n'):
                        if not line.strip() or 'State' in line:
                            continue
                        parts = line.split()
                        if len(parts) >= 5:
                            remote = parts[4]
                            ip = remote.split(':')[0]
                            if not self.is_private_ip(ip):
                                connections.append(ip)
                except subprocess.CalledProcessError:
                    # Fallback to netstat if ss fails
                    result = subprocess.check_output('netstat -tn', shell=True, stderr=subprocess.DEVNULL).decode('utf-8')
                    for line in result.split('\n'):
                        if 'ESTABLISHED' in line:
                            parts = line.split()
                            if len(parts) >= 5:
                                remote = parts[4]
                                ip = remote.split(':')[0]
                                if not self.is_private_ip(ip):
                                    connections.append(ip)
            
            return connections
        except Exception as e:
            logging.error(f"Error getting connections: {e}")
            return []
    
    def is_private_ip(self, ip):
        """Check if an IP address is in a private range"""
        try:
            return ipaddress.ip_address(ip).is_private
        except ValueError:
            return False
    
    def run_detection_cycle(self):
        """Run a full VPN detection cycle using all available methods"""
        detected_vpns = []
        
        # Method 1: Check current connections against known VPN IPs
        connections = self.get_current_connections()
        for ip in connections:
            if self.check_connection_against_known_vpns(ip):
                detected_vpns.append(("Known VPN IP", ip))
        
        # Method 2: DNS leak detection
        detected_vpns.extend(self.detect_vpn_by_dns_leak())
        
        # Method 3: Port scanning
        detected_vpns.extend(self.detect_vpn_by_port_scan())
        
        # Method 4: Process name detection
        detected_vpns.extend(self.check_vpn_process_names())
        
        # Method 5: Interface detection (fallback for netifaces)
        detected_vpns.extend(self.detect_vpn_interfaces())
        
        # Method 6: Network traffic analysis (if scapy is available)
        if SCAPY_AVAILABLE:
            detected_vpns.extend(self.analyze_network_traffic())
        
        # Block detected VPN connections
        for detection_type, target in detected_vpns:
            if detection_type == "Known VPN IP" or detection_type == "Traffic Analysis" or detection_type == "VPN Port Traffic":
                if "." in target and not self.is_private_ip(target):  # It looks like a public IP address
                    self.block_ip(target)
        
        return detected_vpns

    def is_admin(self):
        """Check if running with admin privileges"""
        if self.os_type == "Windows":
            return self.is_admin_windows()
        else:
            return self.is_admin_linux()
    
    def is_admin_windows(self):
        """Check if running with admin privileges on Windows"""
        try:
            # Try the direct approach using ctypes
            import ctypes
            return ctypes.windll.shell32.IsUserAnAdmin() != 0
        except Exception as e:
            logging.error(f"Admin check failed with ctypes: {e}")
            # Fallback to checking using system commands
            try:
                # Use 'net session' command which requires admin rights
                devnull = open(os.devnull, 'w')
                subprocess.check_call(['net', 'session'], stdout=devnull, stderr=devnull)
                devnull.close()
                return True
            except Exception:
                return False
    
    def is_admin_linux(self):
        """Check if running with admin privileges on Linux"""
        return os.geteuid() == 0
    
    def block_vpn_windows(self):
        """Implement comprehensive VPN blocking on Windows"""
        try:
            # Make sure we're running with admin privileges
            if not self.is_admin_windows():
                return {
                    "success": False, 
                    "message": "Administrator privileges required for VPN blocking."
                }
            
            # First, run detection cycle to find and block any VPN connections
            detected_vpns = self.run_detection_cycle()
            
            # Create a script that doesn't run continuously
            script_path = os.path.join(tempfile.gettempdir(), 'vpn_blocker_script.py')
            
            script_content = """
import subprocess
import time
import os
import sys
import logging
import json
from datetime import datetime

# Setup logging to file in temp directory
log_file = os.path.join(os.environ.get('TEMP', '.'), 'vpn_blocker.log')
logging.basicConfig(filename=log_file, level=logging.INFO, format="%(asctime)s - %(message)s")

# Constants for VPN-specific ports and protocols
VPN_PORTS = [1194, 500, 4500, 1701, 1723, 51820, 443]
VPN_PROTOCOLS = ["UDP", "TCP"]
VPN_PROTOCOL_NUMBERS = {"GRE": 47, "ESP": 50, "AH": 51}
VPN_PROCESSES = ["openvpn.exe", "nordvpn.exe", "expressvpn.exe", "protonvpn.exe", 
                "ipsec.exe", "softether.exe", "wireguard.exe"]
VPN_DOMAINS = ["nordvpn.com", "expressvpn.com", "protonvpn.com", "surfshark.com", 
               "cyberghostvpn.com", "pia.com", "privateinternetaccess.com",
               "mullvad.net", "vyprvpn.com", "torguard.net", "purevpn.com", 
               "ipvanish.com", "tunnelbear.com", "windscribe.com", "hidemyass.com", 
               "strongvpn.com"]

def is_admin():
    \"\"\"Check if the script is running with admin privileges.\"\"\"
    try:
        import ctypes
        return ctypes.windll.shell32.IsUserAnAdmin() != 0
    except Exception:
        # Fallback to checking using system commands
        try:
            devnull = open(os.devnull, 'w')
            subprocess.check_call(['net', 'session'], stdout=devnull, stderr=devnull)
            devnull.close()
            return True
        except Exception:
            return False

def run_as_admin():
    \"\"\"Ensure the script is running with administrative privileges.\"\"\"
    if not is_admin():
        print("This script requires administrative privileges. Exiting...")
        logging.error("Script not running with admin privileges")
        sys.exit(1)

def block_vpn_ports():
    \"\"\"Block VPN-specific ports using Windows Firewall.\"\"\"
    print("Blocking VPN-specific ports via Windows Firewall...")
    logging.info("Blocking VPN-specific ports")
    
    # Use netsh for blocking
    firewall_cmd_base = 'netsh advfirewall firewall add rule name="Block VPN {} Port {}" dir=out action=block protocol={} localport={} enable=yes'
    
    for protocol in VPN_PROTOCOLS:
        for port in VPN_PORTS:
            cmd = firewall_cmd_base.format(protocol, port, protocol, port)
            try:
                subprocess.run(cmd, shell=True, check=False, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                print(f"Blocked {protocol} port {port}")
            except Exception as e:
                logging.error(f"Error blocking {protocol} port {port}: {e}")

def block_vpn_protocols():
    \"\"\"Block VPN-specific protocols using Windows Firewall.\"\"\"
    print("Blocking VPN-specific protocols...")
    logging.info("Blocking VPN protocols")
    
    firewall_cmd_base = 'netsh advfirewall firewall add rule name="Block VPN Protocol {}" dir=out action=block protocol={} enable=yes'
    
    for protocol_name, protocol_number in VPN_PROTOCOL_NUMBERS.items():
        cmd = firewall_cmd_base.format(protocol_name, protocol_number)
        try:
            subprocess.run(cmd, shell=True, check=False, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            print(f"Blocked protocol {protocol_name}")
        except Exception as e:
            logging.error(f"Error blocking protocol {protocol_name}: {e}")

def block_vpn_domains():
    \"\"\"Block DNS resolution of known VPN domains using hosts file.\"\"\"
    print("Blocking VPN domains via hosts file...")
    logging.info("Blocking VPN domains")
    
    hosts_path = r"C:\\Windows\\System32\\drivers\\etc\\hosts"
    redirect_ip = "127.0.0.1"  # Redirect to localhost
    
    try:
        # Read existing content first
        with open(hosts_path, "r") as hosts_file:
            content = hosts_file.read()
            
        # Append domains only if they don't exist
        with open(hosts_path, "a+") as hosts_file:
            hosts_file.write("\\n# VPN Blocking entries added by CheckBlock\\n")
            for domain in VPN_DOMAINS:
                if domain not in content:
                    hosts_file.write(f"{redirect_ip} {domain}\\n")
                    hosts_file.write(f"{redirect_ip} www.{domain}\\n")
                    print(f"Blocked VPN domain: {domain}")
    except Exception as e:
        logging.error(f"Error modifying hosts file: {e}")

def disable_vpn_adapters():
    \"\"\"Disable network adapters associated with VPN connections.\"\"\"
    print("Disabling VPN network adapters...")
    logging.info("Disabling VPN adapters")
    
    try:
        # Get network adapters using netsh
        output = subprocess.check_output("netsh interface show interface", shell=True, universal_newlines=True)
        for line in output.split('\\n'):
            if any(keyword in line.lower() for keyword in ["vpn", "virtual", "tunnel", "tap"]):
                adapter_name = line.split()[-1]  # Get adapter name from last column
                disable_cmd = f'netsh interface set interface "{adapter_name}" disabled'
                try:
                    subprocess.run(disable_cmd, shell=True, check=False)
                    print(f"Disabled VPN adapter: {adapter_name}")
                except Exception as e:
                    logging.error(f"Error disabling adapter {adapter_name}: {e}")
    except Exception as e:
        logging.error(f"Error in disable_vpn_adapters: {e}")

def stop_vpn_services():
    \"\"\"Stop and disable services commonly used by VPN software.\"\"\"
    print("Stopping and disabling VPN-related services...")
    logging.info("Stopping VPN services")
    
    vpn_services = [
        "RasMan",  # Remote Access Connection Manager (used by many VPNs)
        "IKEEXT",  # IKE and AuthIP IPsec Keying Modules
        "PolicyAgent",  # IPsec Policy Agent
    ]
    
    for service in vpn_services:
        try:
            # Use SC command to stop and disable services
            subprocess.run(f'sc stop {service}', shell=True, check=False)
            subprocess.run(f'sc config {service} start= disabled', shell=True, check=False)
            print(f"Stopped and disabled service: {service}")
        except Exception as e:
            logging.error(f"Error managing service {service}: {e}")

def terminate_vpn_processes():
    \"\"\"Detect and terminate VPN-related processes.\"\"\"
    print("Scanning for and terminating VPN-related processes...")
    logging.info("Terminating VPN processes")
    
    try:
        # Get process list using tasklist
        output = subprocess.check_output("tasklist /FO CSV", shell=True, universal_newlines=True)
        for vpn_process in VPN_PROCESSES:
            if vpn_process.lower() in output.lower():
                try:
                    # Try to terminate the process using taskkill
                    subprocess.run(f'taskkill /F /IM "{vpn_process}"', shell=True, check=False)
                    print(f"Terminated VPN process: {vpn_process}")
                except Exception as e:
                    logging.error(f"Error terminating process: {e}")
    except Exception as e:
        logging.error(f"Error in terminate_vpn_processes: {e}")

def main():
    \"\"\"Main function to orchestrate VPN blocking.\"\"\"
    run_as_admin()  # Ensure script runs with admin privileges

    print("Starting VPN blocking script...")
    logging.info("Starting VPN blocking script")

    # Block everything in one go - no continuous monitoring
    block_vpn_ports()
    block_vpn_protocols()
    block_vpn_domains()
    disable_vpn_adapters()
    stop_vpn_services()
    terminate_vpn_processes()

    print("VPN blocking has been applied successfully.")
    logging.info("VPN blocking applied successfully")

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        import traceback
        print(f"Unexpected error: {e}")
        traceback.print_exc()
"""
            
            # Write the script to a file
            with open(script_path, 'w') as f:
                f.write(script_content)
                
            # Execute script directly (not in background) and wait for completion
            try:
                subprocess.run([sys.executable, script_path], check=True)
                
                # Create detection summary
                detection_summary = ""
                if detected_vpns:
                    detection_summary = f" Detected and blocked {len(detected_vpns)} VPN connections."
                
                return {
                    "success": True, 
                    "message": f"Windows VPN blocking has been applied successfully.{detection_summary}"
                }
            except Exception as e:
                return {
                    "success": False, 
                    "message": f"Failed to apply VPN blocking: {str(e)}"
                }
        except Exception as e:
            logging.error(f"Failed to start Windows VPN blocking: {e}")
            return {
                "success": False, 
                "message": f"Failed to apply VPN blocking: {str(e)}"
            }

    def stop_blocking_windows(self):
        """Stop VPN blocking on Windows"""
        try:
            # Run cleanup script that will remove firewall rules and hosts file entries
            cleanup_script_path = os.path.join(tempfile.gettempdir(), 'vpn_cleanup.py')
            
            cleanup_script = """
import subprocess
import os
import sys
import logging

# Setup logging to file in temp directory
log_file = os.path.join(os.environ.get('TEMP', '.'), 'vpn_blocker_cleanup.log')
logging.basicConfig(filename=log_file, level=logging.INFO, format="%(asctime)s - %(message)s")

def is_admin():
    \"\"\"Check if the script is running with admin privileges.\"\"\"
    try:
        # Try the direct approach using ctypes
        import ctypes
        return ctypes.windll.shell32.IsUserAnAdmin() != 0
    except Exception:
        # Fallback to checking using system commands
        try:
            # Use 'net session' command which requires admin rights
            devnull = open(os.devnull, 'w')
            subprocess.check_call(['net', 'session'], stdout=devnull, stderr=devnull)
            devnull.close()
            return True
        except Exception:
            return False

def run_as_admin():
    \"\"\"Ensure the script is running with administrative privileges.\"\"\"
    if not is_admin():
        print("This script requires administrative privileges. Exiting...")
        logging.error("Script not running with admin privileges")
        sys.exit(1)

def cleanup():
    \"\"\"Clean up VPN blocking rules.\"\"\"
    print("Cleaning up VPN blocking rules...")
    logging.info("Starting VPN blocking cleanup")
    
    # VPN-specific ports and protocols to unblock
    VPN_PORTS = [1194, 500, 4500, 1701, 1723, 51820, 443]
    VPN_PROTOCOLS = ["UDP", "TCP"]
    VPN_PROTOCOL_NUMBERS = {"GRE": 47, "ESP": 50, "AH": 51}
    VPN_DOMAINS = [
        "nordvpn.com", "expressvpn.com", "protonvpn.com", "surfshark.com", 
        "cyberghostvpn.com", "pia.com", "privateinternetaccess.com",
        "mullvad.net", "vyprvpn.com", "torguard.net", "purevpn.com", "ipvanish.com",
        "tunnelbear.com", "windscribe.com", "hidemyass.com", "cyberghostvpn.com", "strongvpn.com"
    ]

    # Remove firewall rules for VPN ports
    for protocol in VPN_PROTOCOLS:
        for port in VPN_PORTS:
            try:
                cmd = f'netsh advfirewall firewall delete rule name="Block VPN {protocol} Port {port}"'
                subprocess.run(cmd, shell=True, check=False)
                print(f"Removed port blocking rule for {protocol} port {port}")
            except Exception as e:
                logging.error(f"Error removing rule: {e}")

    # Remove firewall rules for VPN protocols
    for protocol_name, protocol_number in VPN_PROTOCOL_NUMBERS.items():
        try:
            cmd = f'netsh advfirewall firewall delete rule name="Block VPN Protocol {protocol_name}"'
            subprocess.run(cmd, shell=True, check=False)
            print(f"Removed protocol blocking rule for {protocol_name}")
        except Exception as e:
            logging.error(f"Error removing rule: {e}")

    # Remove any IP range blocking rules with wildcard
    try:
        cmd = 'netsh advfirewall firewall delete rule name="Block VPN IP Range*"'
        subprocess.run(cmd, shell=True, check=False)
        print("Removed IP range blocking rules")
    except Exception as e:
        logging.error(f"Error removing IP range rules: {e}")
    
    # Remove any BlockVPN rules
    try:
        cmd = 'netsh advfirewall firewall delete rule name="BlockVPN*"'
        subprocess.run(cmd, shell=True, check=False)
        print("Removed individual VPN IP blocking rules")
    except Exception as e:
        logging.error(f"Error removing BlockVPN rules: {e}")

    # Clean up hosts file entries
    hosts_path = r"C:\\Windows\\System32\\drivers\\etc\\hosts"
    try:
        # First read current hosts file
        with open(hosts_path, "r") as hosts_file:
            lines = hosts_file.readlines()
        
        # Write back only non-VPN entries
        with open(hosts_path, "w") as hosts_file:
            in_block_section = False
            for line in lines:
                # Skip lines related to VPN blocking
                if "VPN Blocking entries added by CheckBlock" in line:
                    in_block_section = True
                    continue
                    
                if in_block_section and not line.strip():
                    # Empty line means end of our block
                    in_block_section = False
                
                if not in_block_section and not any(domain in line for domain in VPN_DOMAINS):
                    hosts_file.write(line)
                    
        print("Cleaned up hosts file entries")
    except Exception as e:
        logging.error(f"Error cleaning hosts file: {e}")

    # Re-enable VPN services
    vpn_services = ["RasMan", "IKEEXT", "PolicyAgent"]
    for service in vpn_services:
        try:
            cmd = f'sc config {service} start= demand'
            subprocess.run(cmd, shell=True, check=False)
            cmd = f'sc start {service}'
            subprocess.run(cmd, shell=True, check=False)
            print(f"Re-enabled service: {service}")
        except Exception as e:
            logging.error(f"Error re-enabling service {service}: {e}")

    # Re-enable any disabled network adapters that contain VPN-related names
    try:
        output = subprocess.check_output("netsh interface show interface", shell=True, universal_newlines=True)
        for line in output.split('\\n'):
            if "Disabled" in line and any(keyword in line.lower() for keyword in ["vpn", "virtual", "tunnel", "tap"]):
                adapter_name = line.split()[-1]  # Get adapter name from last column
                try:
                    subprocess.run(f'netsh interface set interface "{adapter_name}" enabled', shell=True, check=False)
                    print(f"Re-enabled network adapter: {adapter_name}")
                except Exception as e:
                    logging.error(f"Error enabling adapter {adapter_name}: {e}")
    except Exception as e:
        logging.error(f"Error re-enabling network adapters: {e}")

    # Kill all VPN blocker processes
    try:
        # Use taskkill to find and terminate Python processes
        subprocess.run('taskkill /f /im python.exe /fi "WINDOWTITLE eq vpn_blocker*"', shell=True, check=False)
        subprocess.run('taskkill /f /im pythonw.exe /fi "WINDOWTITLE eq vpn_blocker*"', shell=True, check=False)
    except Exception as e:
        logging.error(f"Error terminating processes: {e}")

    print("VPN blocking cleanup completed")

def main():
    run_as_admin()
    cleanup()
    print("VPN blocking has been successfully disabled.")

if __name__ == "__main__":
    main()
"""

            # Write the cleanup script to a file
            with open(cleanup_script_path, 'w') as f:
                f.write(cleanup_script)
            
            # Run the cleanup script with admin privileges
            startupinfo = None
            if hasattr(subprocess, 'STARTUPINFO'):
                startupinfo = subprocess.STARTUPINFO()
                startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
            
            try:
                subprocess.run(
                    [sys.executable, cleanup_script_path],
                    startupinfo=startupinfo,
                    check=False
                )
                
                # Also try to kill any Python processes related to VPN blocking
                try:
                    if platform.system() == "Windows":
                        subprocess.run('taskkill /f /im python.exe /fi "WINDOWTITLE eq vpn_blocker*"', 
                                    shell=True, check=False)
                        subprocess.run('taskkill /f /im pythonw.exe /fi "WINDOWTITLE eq vpn_blocker*"', 
                                    shell=True, check=False)
                except Exception as e:
                    logging.error(f"Error terminating VPN blocker processes: {e}")
                    
                return {
                    "success": True, 
                    "message": "VPN blocking has been stopped successfully."
                }
            except Exception as e:
                return {
                    "success": False, 
                    "message": f"Failed to stop VPN blocking: {str(e)}"
                }
        except Exception as e:
            return {
                "success": False, 
                "message": f"Failed to stop VPN blocking: {str(e)}"
            }
    
    def block_vpn_linux(self):
        """Implement strict VPN blocking on Linux with enhanced iptables rules"""
        try:
            # First, run detection cycle to find and block any VPN connections
            detected_vpns = self.run_detection_cycle()
            
            # Setup iptables chains for enhanced blocking
            logging.info("Setting up iptables chains for enhanced VPN blocking")
            if not self.setup_iptables_chains():
                logging.error("Failed to setup iptables chains")
            
            # Apply VPN provider specific rules
            logging.info("Applying VPN provider specific blocking rules")
            provider_success = self.apply_vpn_provider_rules()
            
            # Setup CIDR and port blocking
            logging.info("Setting up CIDR and port blocking")
            cidr_success = self.setup_cidr_blocking()
            
            # Continue with existing blocking methods below
            # (Keep all your existing code from the current block_vpn_linux method)
            
            # 1. Block kernel modules
            kernel_blocks = [
                "install tun /bin/true",
                "install tap /bin/true",
                "install ppp_generic /bin/true"
            ]
            
            # Create blacklist file
            try:
                with open("/etc/modprobe.d/vpn_blacklist.conf", "w") as f:
                    for block in kernel_blocks:
                        f.write(f"{block}\n")
            except Exception as e:
                logging.error(f"Failed to create kernel module blacklist: {str(e)}")
            
            # 2. Remove existing kernel modules
            modules_to_remove = ["tun", "tap", "ppp_generic"]
            for module in modules_to_remove:
                try:
                    subprocess.run(["rmmod", module], stderr=subprocess.DEVNULL)
                except Exception:
                    pass
            
            # 3. Create strict iptables rules
            iptables_rules = [
                # Block common VPN ports
                "iptables -A OUTPUT -p udp --dport 1194 -j DROP",  # OpenVPN
                "iptables -A OUTPUT -p tcp --dport 1194 -j DROP",
                "iptables -A OUTPUT -p udp --dport 500 -j DROP",   # IKEv2
                "iptables -A OUTPUT -p udp --dport 4500 -j DROP",
                "iptables -A OUTPUT -p tcp --dport 1723 -j DROP",  # PPTP
                "iptables -A OUTPUT -p udp --dport 51820 -j DROP", # WireGuard
                
                # Block DNS
                "iptables -A OUTPUT -p udp --dport 53 -j DROP",
                "iptables -A OUTPUT -p tcp --dport 53 -j DROP",

                # Block VPN interfaces
                "iptables -A OUTPUT -o tun+ -j DROP",
                "iptables -A OUTPUT -o tap+ -j DROP",
                "iptables -A OUTPUT -o ppp+ -j DROP",

                # Block known VPN provider IPs (pattern matching)
                "iptables -A OUTPUT -m string --string 'openvpn' --algo bm -j DROP",
                "iptables -A OUTPUT -m string --string 'vpn' --algo bm -j DROP"
            ]
            
            for rule in iptables_rules:
                try:
                    subprocess.run(rule.split(), check=False, stderr=subprocess.DEVNULL)
                except Exception:
                    pass
                    
            # Try to save iptables rules
            try:
                # Check for iptables-save command and appropriate directory
                if os.path.exists("/sbin/iptables-save") or os.path.exists("/usr/sbin/iptables-save"):
                    if not os.path.exists("/etc/iptables"):
                        os.makedirs("/etc/iptables")
                    subprocess.run("iptables-save > /etc/iptables/rules.v4", shell=True, check=False)
            except Exception:
                pass
            
            # 4. Disable and mask VPN services
            for service in VPN_SERVICES["Linux"]:
                try:
                    subprocess.run(["systemctl", "stop", service], stderr=subprocess.DEVNULL)
                    subprocess.run(["systemctl", "disable", service], stderr=subprocess.DEVNULL)
                    subprocess.run(["systemctl", "mask", service], stderr=subprocess.DEVNULL)
                except Exception:
                    continue
            
            # 5. Try to remove VPN software
            package_managers = {
                "apt-get": "apt-get purge -y",
                "yum": "yum remove -y",
                "dnf": "dnf remove -y",
                "pacman": "pacman -R --noconfirm"
            }
            
            for pm, cmd in package_managers.items():
                if subprocess.run(["which", pm], stderr=subprocess.DEVNULL, stdout=subprocess.DEVNULL).returncode == 0:
                    for service in VPN_SERVICES["Linux"]:
                        try:
                            subprocess.run(f"{cmd} {service}", shell=True, stderr=subprocess.DEVNULL, check=False)
                        except Exception:
                            pass
            
            # 6. Block VPN-related directories
            vpn_dirs = [
                "/etc/openvpn",
                "/etc/wireguard",
                "/etc/strongswan",
                "/etc/xl2tpd"
            ]
            
            for directory in vpn_dirs:
                if os.path.exists(directory):
                    try:
                        # Make directory immutable
                        subprocess.run(["chattr", "+i", directory], check=False, stderr=subprocess.DEVNULL)
                    except Exception:
                        continue
            
            # 7. Set up persistent blocking
            blocker_script = '''#!/bin/bash
while true; do
    # Continuously enforce VPN blocking
    rmmod tun tap ppp_generic 2>/dev/null

    # Kill any VPN-related processes
    pkill -f "openvpn|vpn|tunnel|tun|tap|ppp|l2tp|ipsec|strongswan|wireguard"

    # Re-apply iptables rules if directory exists
    if [ -f "/etc/iptables/rules.v4" ]; then
        iptables-restore < /etc/iptables/rules.v4
    fi

    sleep 5
done
'''
            try:
                with open("/usr/local/bin/vpn_blocker", "w") as f:
                    f.write(blocker_script)
                os.chmod("/usr/local/bin/vpn_blocker", 0o755)
                
                service_content = '''
[Unit]
Description=VPN Blocking Service
After=network.target

[Service]
Type=simple
ExecStart=/usr/local/bin/vpn_blocker
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
'''
                with open("/etc/systemd/system/vpn_blocker.service", "w") as f:
                    f.write(service_content)
                
                subprocess.run(["systemctl", "daemon-reload"])
                subprocess.run(["systemctl", "enable", "vpn_blocker"], stderr=subprocess.DEVNULL)
                subprocess.run(["systemctl", "start", "vpn_blocker"], stderr=subprocess.DEVNULL)
            except Exception as e:
                logging.error(f"Failed to create blocker service: {str(e)}")
            
            # 8. Modify hosts file to block VPN domains
            try:
                with open("/etc/hosts", "a") as hosts_file:
                    hosts_file.write("\n# VPN Provider Blocks added by CheckBlock\n")
                    for domain in VPN_DOMAINS:
                        hosts_file.write(f"127.0.0.1 {domain}\n")
                        hosts_file.write(f"127.0.0.1 www.{domain}\n")
            except Exception as e:
                logging.error(f"Failed to modify hosts file: {str(e)}")
            
            # Additional status reporting for our new methods
            enhanced_status = ""
            if provider_success:
                enhanced_status += " VPN provider rules applied."
            if cidr_success:
                enhanced_status += " CIDR/port blocking active."
            
            # Create detection summary
            detection_summary = ""
            if detected_vpns:
                detection_summary = f" Initially detected and blocked {len(detected_vpns)} VPN connections."
            
            return {
                "success": True, 
                "message": f"Linux VPN blocking measures implemented. Kernel modules blocked, iptables rules added, VPN services disabled.{detection_summary}{enhanced_status}"
            }
        except Exception as e:
            return {
                "success": False, 
                "message": f"Failed to apply Linux VPN blocking: {str(e)}"
            }
    
    def stop_blocking_linux(self):
        """Stop VPN blocking on Linux"""
        try:
            # Remove kernel module blacklist
            try:
                if os.path.exists("/etc/modprobe.d/vpn_blacklist.conf"):
                    os.remove("/etc/modprobe.d/vpn_blacklist.conf")
            except Exception:
                pass
            
            # Remove iptables rules (flush chains)
            try:
                subprocess.run(["iptables", "-F", "OUTPUT"])
            except Exception:
                pass
            
            # Stop and remove blocker service
            try:
                subprocess.run(["systemctl", "stop", "vpn_blocker"], stderr=subprocess.DEVNULL)
                subprocess.run(["systemctl", "disable", "vpn_blocker"], stderr=subprocess.DEVNULL)
                subprocess.run(["systemctl", "unmask", "vpn_blocker"], stderr=subprocess.DEVNULL)
                
                if os.path.exists("/etc/systemd/system/vpn_blocker.service"):
                    os.remove("/etc/systemd/system/vpn_blocker.service")
                
                if os.path.exists("/usr/local/bin/vpn_blocker"):
                    os.remove("/usr/local/bin/vpn_blocker")
                    
                subprocess.run(["systemctl", "daemon-reload"])
            except Exception:
                pass
                
            # Unblock VPN directories
            vpn_dirs = [
                "/etc/openvpn",
                "/etc/wireguard",
                "/etc/strongswan",
                "/etc/xl2tpd"
            ]
            
            for directory in vpn_dirs:
                if os.path.exists(directory):
                    try:
                        # Remove immutable attribute
                        subprocess.run(["chattr", "-i", directory], check=False)
                    except Exception:
                        continue
                        
            # Cleanup hosts file
            try:
                with open("/etc/hosts", "r") as hosts_file:
                    lines = hosts_file.readlines()
                
                with open("/etc/hosts", "w") as hosts_file:
                    for line in lines:
                        if not any(domain in line for domain in VPN_DOMAINS) and "CheckBlock" not in line:
                            hosts_file.write(line)
            except Exception as e:
                logging.error(f"Failed to cleanup hosts file: {str(e)}")
            
            return {
                "success": True, 
                "message": "Linux VPN blocking measures removed."
            }
        except Exception as e:
            return {
                "success": False, 
                "message": f"Failed to stop Linux VPN blocking: {str(e)}"
            }

    def run_iptables_command(self, command):
        """Execute an iptables command and handle errors."""
        try:
            print(f"Executing: {' '.join(command)}")
            result = subprocess.run(command, capture_output=True, text=True, check=False, timeout=15)
            if result.returncode != 0:
                logging.warning(f"Command failed with exit code {result.returncode}")
                logging.warning(f"Stderr: {result.stderr.strip()}")
                return False
            return True
        except subprocess.TimeoutExpired:
            logging.error(f"Command timed out: {' '.join(command)}")
            return False
        except Exception as e:
            logging.error(f"An unexpected error occurred running command: {e}")
            return False

    def setup_iptables_chains(self):
        """Sets up the initial iptables chains for VPN blocking."""
        # Flush (clean) just our custom block chains (so we can start fresh)
        self.run_iptables_command(['iptables', '-F', CHAIN_NAME_IP])
        self.run_iptables_command(['iptables', '-F', CHAIN_NAME_HTTP])
        self.run_iptables_command(['iptables', '-F', CHAIN_NAME_DNS])
        
        # Create chains if they don't exist
        self.run_iptables_command(['iptables', '-N', CHAIN_NAME_IP])
        self.run_iptables_command(['iptables', '-N', CHAIN_NAME_HTTP])
        self.run_iptables_command(['iptables', '-N', CHAIN_NAME_DNS])

        # Insert our chains at the beginning of the FILTER table
        if (self.run_iptables_command(['iptables', '-I', 'INPUT', '-j', CHAIN_NAME_IP]) and 
            self.run_iptables_command(['iptables', '-I', 'OUTPUT', '-j', CHAIN_NAME_IP]) and 
            self.run_iptables_command(['iptables', '-I', 'OUTPUT', '-p', 'tcp', '--dport', '80', '-j', CHAIN_NAME_HTTP])):
            return True
        return False

    def setup_cidr_blocking(self):
        """Sets up the iptables rules for CIDR and port blocking."""
        logging.info("Setting up CIDR and port blocking with iptables")
        
        # Create chain if needed
        self.run_iptables_command(['iptables', '-N', IPTABLES_CHAIN])
        self.run_iptables_command(['iptables', '-F', IPTABLES_CHAIN])

        # Add rules to block known VPN CIDRs
        success_count = 0
        for cidr in KNOWN_VPN_CIDRS:
            if self.run_iptables_command(['iptables', '-A', IPTABLES_CHAIN, '-d', cidr, '-j', 'DROP']):
                success_count += 1
        logging.info(f"Added {success_count} CIDR rules")

        # Add rules to block common VPN ports/protocols
        success_count = 0
        for item in VPN_PORTS_PROTOCOLS_EXTENDED:
            cmd = ['iptables', '-A', IPTABLES_CHAIN, '-p', item['protocol'].lower()]
            if 'port' in item:
                cmd.extend(['--dport', item['port']])
            cmd.extend(['-j', 'DROP'])
            if self.run_iptables_command(cmd):
                success_count += 1
        logging.info(f"Added {success_count} port/protocol rules")

        # Jump from the main OUTPUT chain to our custom chain
        check_cmd = ['iptables', '-C', 'OUTPUT', '-j', IPTABLES_CHAIN]
        rule_exists = subprocess.run(check_cmd, capture_output=True).returncode == 0

        if not rule_exists:
            if not self.run_iptables_command(['iptables', '-I', 'OUTPUT', '1', '-j', IPTABLES_CHAIN]):
                logging.error("Failed to insert jump rule. Blocking may not be active.")
                return False
        return True

    def block_ip_extended(self, ip, port=None, proto=None):
        """Block an IP address with optional port/protocol using iptables."""
        if port and proto:
            rule = ['iptables', '-A', CHAIN_NAME_IP, '-p', proto, '-s', ip, '--dport', str(port), '-j', 'DROP']
        else:
            rule = ['iptables', '-A', CHAIN_NAME_IP, '-s', ip, '-j', 'DROP']
        
        if self.run_iptables_command(rule):
            logging.info(f"Blocked IP {ip}" + (f", port {port}/{proto}" if port else ""))
            return True
        return False

    def block_ip_range_extended(self, cidr):
        """Block an IP range (CIDR) using iptables."""
        rule = ['iptables', '-A', CHAIN_NAME_IP, '-s', cidr, '-j', 'DROP']
        if self.run_iptables_command(rule):
            logging.info(f"Blocked IP range {cidr}")
            return True
        return False

    def resolve_and_block(self, hostname):
        """Resolve a hostname to IPs and block them."""
        try:
            ips = subprocess.check_output(['dig', '+short', hostname]).decode().strip().split('\n')
            success = True
            for ip in ips:
                if ip and not self.block_ip_extended(ip):
                    success = False
            return success
        except subprocess.CalledProcessError:
            logging.error(f"Failed to resolve {hostname}")
            return False

    def block_ssl_fingerprint(self, fingerprint):
        """Block a specific SSL certificate fingerprint."""
        rule = ['iptables', '-A', CHAIN_NAME_IP, '-p', 'tcp', '--dport', '443', 
                '-m', 'ssl', '--ssl-fingerprint', fingerprint, '-j', 'DROP']
        if self.run_iptables_command(rule):
            logging.info(f"Blocked SSL fingerprint {fingerprint}")
            return True
        return False

    def block_http_user_agent(self, user_agent):
        """Block a specific HTTP User-Agent."""
        rule = ['iptables', '-A', CHAIN_NAME_HTTP, '-p', 'tcp', '--dport', '80', 
                '-m', 'string', '--algo', 'bm', '--string', user_agent, '-j', 'DROP']
        if self.run_iptables_command(rule):
            logging.info(f"Blocked HTTP User-Agent '{user_agent}'")
            return True
        return False

    def block_dns_pattern(self, pattern):
        """Block DNS patterns using dnsmasq."""
        try:
            with open("/etc/dnsmasq.d/vpn-block.conf", "a") as f:
                f.write(f"address=/{pattern}/0.0.0.0\n")
            if subprocess.run(['systemctl', 'restart', 'dnsmasq']).returncode == 0:
                logging.info(f"Blocked DNS pattern '{pattern}'")
                return True
            return False
        except Exception as e:
            logging.error(f"Error blocking DNS pattern: {e}")
            return False

    def block_asn(self, asn_number):
        """Block an entire ASN (Autonomous System Number)."""
        success = True
        try:
            netblocks = subprocess.check_output(['whois', '-i', 'origin', str(asn_number)]).decode()
            cidrs = re.findall(r'(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/\d{1,2})', netblocks)
            for cidr in cidrs:
                if not self.block_ip_range_extended(cidr):
                    success = False
            return success
        except subprocess.CalledProcessError:
            logging.error(f"Failed to fetch ASN{asn_number} netblocks")
            return False

    def block_domain(self, domain):
        """Block a domain name using string matching in HTTP traffic."""
        rule = ['iptables', '-A', CHAIN_NAME_HTTP, '-p', 'tcp', '--dport', '80', 
                '-m', 'string', '--algo', 'bm', '--string', domain, '-j', 'DROP']
        if self.run_iptables_command(rule):
            logging.info(f"Blocked domain '{domain}'")
            return True
        return False

    def apply_vpn_provider_rules(self):
        """Apply all VPN provider specific blocking rules."""
        success = True
        for provider, entries in VPN_PROVIDERS_EXTENDED.items():
            logging.info(f"Processing {provider}...")
            for entry in entries:
                if 'ip' in entry:
                    if not self.block_ip_extended(entry['ip'], entry.get('port'), entry.get('proto')):
                        success = False
                if 'ip_range' in entry:
                    if not self.block_ip_range_extended(entry['ip_range']):
                        success = False
                if 'hostname' in entry:
                    if not self.resolve_and_block(entry['hostname']):
                        success = False
                if 'ssl_fingerprint' in entry:
                    if not self.block_ssl_fingerprint(entry['ssl_fingerprint']):
                        success = False
                if 'http_user_agent' in entry:
                    if not self.block_http_user_agent(entry['http_user_agent']):
                        success = False
                if 'dns_name_pattern' in entry:
                    if not self.block_dns_pattern(entry['dns_name_pattern']):
                        success = False
                if 'asn_number' in entry:
                    if not self.block_asn(entry['asn_number']):
                        success = False
                if 'known_vpn_domains' in entry:
                    for domain in entry['known_vpn_domains']:
                        if not self.block_domain(domain):
                            success = False
        return success

    def cleanup_iptables_chains(self):
        """Cleanup the custom iptables chains created for VPN blocking."""
        logging.info("Cleaning up iptables chains...")
        
        # Remove jump rules
        self.run_iptables_command(['iptables', '-D', 'INPUT', '-j', CHAIN_NAME_IP])
        self.run_iptables_command(['iptables', '-D', 'OUTPUT', '-j', CHAIN_NAME_IP])
        self.run_iptables_command(['iptables', '-D', 'OUTPUT', '-p', 'tcp', '--dport', '80', '-j', CHAIN_NAME_HTTP])
        
        # Check if our IPTABLES_CHAIN jump rule exists and remove it
        check_cmd = ['iptables', '-C', 'OUTPUT', '-j', IPTABLES_CHAIN]
        if subprocess.run(check_cmd, capture_output=True).returncode == 0:
            self.run_iptables_command(['iptables', '-D', 'OUTPUT', '-j', IPTABLES_CHAIN])
        
        # Flush and delete the chains
        self.run_iptables_command(['iptables', '-F', CHAIN_NAME_IP])
        self.run_iptables_command(['iptables', '-X', CHAIN_NAME_IP])
        self.run_iptables_command(['iptables', '-F', CHAIN_NAME_HTTP])
        self.run_iptables_command(['iptables', '-X', CHAIN_NAME_HTTP])
        self.run_iptables_command(['iptables', '-F', CHAIN_NAME_DNS])
        self.run_iptables_command(['iptables', '-X', CHAIN_NAME_DNS])
        self.run_iptables_command(['iptables', '-F', IPTABLES_CHAIN])
        self.run_iptables_command(['iptables', '-X', IPTABLES_CHAIN])
        
        logging.info("iptables chains cleaned up")

def run_as_admin():
    """Ensure the script is running with administrative privileges."""
    os_type = platform.system()
    
    # Check if we're admin
    if os_type == "Windows":
        try:
            import ctypes
            is_admin = ctypes.windll.shell32.IsUserAnAdmin() != 0
        except Exception:
            is_admin = False
    else:  # Linux/Unix
        try:
            is_admin = os.geteuid() == 0
        except AttributeError:
            is_admin = False
    
    if not is_admin:
        print("This script requires administrative privileges. Exiting...")
        logging.error("Script not running with admin privileges")
        sys.exit(1)


def cleanup():
    """Clean up VPN blocking rules."""
    print("Cleaning up VPN blocking rules...")
    logging.info("Starting VPN blocking cleanup")
    
    blocker = VPNBlocker()
    
    if platform.system() == "Windows":
        result = blocker.stop_blocking_windows()
    else:
        result = blocker.stop_blocking_linux()
    
    print(f"Result: {result['message']}")


def main():
    """Main function to run the VPN detection and blocking."""
    # Configure argument parser
    if len(sys.argv) > 1:
        if sys.argv[1] == "start":
            action = "start"
        elif sys.argv[1] == "stop":
            action = "stop"
        elif sys.argv[1] == "cleanup":
            run_as_admin()
            cleanup()
            return
        else:
            print(f"Unknown action: {sys.argv[1]}")
            print("Usage: vpn_blocking.py [start|stop|cleanup]")
            return
    else:
        action = "start"  # Default action
    
    # Ensure admin privileges
    run_as_admin()
    
    # Create VPN blocker
    blocker = VPNBlocker()
    
    if action == "start":
        print("Starting VPN blocking...")
        # Run blocking directly without thread for one-time execution
        if blocker.os_type == "Windows":
            result = blocker.block_vpn_windows()
        else:
            result = blocker.block_vpn_linux()
        print(f"VPN Blocker: {result['message']}")
    else:
        print("Stopping VPN blocking...")
        if blocker.os_type == "Windows":
            result = blocker.stop_blocking_windows()
        else:
            result = blocker.stop_blocking_linux()
        print(f"VPN Blocker: {result['message']}")
    
    # No infinite loop - just exit after operation is complete
    print("VPN blocking operation completed")


if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        logging.error(f"Unexpected error: {e}")
        import traceback
        traceback.print_exc()
    finally:
        # Ensure clean exit
        _ensure_clean_exit()

#mainpage.py

import sys
from PyQt6.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
    QFrame, QScrollArea, QGridLayout, QSizePolicy, QMessageBox, QSpacerItem
)
from PyQt6.QtGui import QFont, QPalette, QColor
from PyQt6.QtCore import Qt, QSize

# --- Color Palette (from Tailwind classes) ---
COLOR_BG_MAIN = "#f8fafc"  # Adjusted from gray-100 for slightly better contrast if needed
COLOR_BG_CARD = "#ffffff"
COLOR_BORDER = "#000000"
COLOR_BG_SECTION = "#f9fafb" # gray-50
COLOR_BG_HIGHLIGHT = "#e5e7eb" # gray-200
COLOR_BORDER_HIGHLIGHT = "#9ca3af" # gray-400
COLOR_VPN_CONNECTED = "#23c55f"
COLOR_VPN_CONNECTED_HOVER = "#199449"
COLOR_VPN_DISCONNECTED = "#ef4545"
COLOR_VPN_DISCONNECTED_HOVER = "#be3737"
COLOR_BUTTON_START = "#23c55f"
COLOR_BUTTON_START_HOVER = "#199449"
COLOR_BUTTON_REFRESH = "#3b83f7"
COLOR_BUTTON_REFRESH_HOVER = "#2a65c9"
COLOR_BUTTON_EXPORT = "#f59f0a"
COLOR_BUTTON_EXPORT_HOVER = "#c47e08"
COLOR_TEXT_DEFAULT = "#000000"
COLOR_TEXT_WHITE = "#ffffff"

# --- Font Sizes (Approximations) ---
FONT_SIZE_XS = 9   # Adjust as needed
FONT_SIZE_SM = 10
FONT_SIZE_LG = 14
FONT_FAMILY_MONO = "Consolas, Courier New, monospace" # Prioritize common monospaces

class RetroDashboardYaakai(QWidget):
    def __init__(self):
        super().__init__()
        self._vpn_connected = False
        self._init_ui()
        self._apply_styles()
        self._update_vpn_ui() # Set initial state

    def _init_ui(self):
        self.setWindowTitle("Checkblock Dashboard")
        self.setMinimumSize(600, 700) # Give some space around the card

        # --- Main Layout (Centers the Card) ---
        main_layout = QHBoxLayout(self)
        main_layout.addStretch(1)  # Push card to center horizontally
        main_layout.addWidget(self._create_card())
        main_layout.addStretch(1)

        # Set overall background
        palette = self.palette()
        palette.setColor(QPalette.ColorRole.Window, QColor(COLOR_BG_MAIN))
        self.setAutoFillBackground(True)
        self.setPalette(palette)

    def _create_card(self):
        # --- Card Container ---
        card_widget = QWidget()
        card_widget.setObjectName("CardWidget")
        card_widget.setFixedWidth(505)

        card_layout = QVBoxLayout(card_widget)
        card_layout.setContentsMargins(24, 24, 24, 24) # p-6
        card_layout.setSpacing(16) # space-y-4 approx

        # --- Header ---
        header_layout = QVBoxLayout()
        header_layout.setSpacing(8) # space between title and line
        header_layout.setContentsMargins(8, 0, 8, 12) # px-2, mb-3

        title_label = QLabel("checkblock")
        title_label.setObjectName("CardTitle")
        title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        header_layout.addWidget(title_label)

        line = QFrame()
        line.setFrameShape(QFrame.Shape.HLine)
        line.setObjectName("HeaderLine")
        header_layout.addWidget(line)

        # 65px empty space
        header_layout.addSpacerItem(QSpacerItem(20, 65, QSizePolicy.Policy.Minimum, QSizePolicy.Policy.Fixed))

        card_layout.addLayout(header_layout)

        # --- Content Sections ---
        content_layout = QVBoxLayout()
        content_layout.setSpacing(16) # space-y-4

        content_layout.addWidget(self._create_ip_info_section())
        content_layout.addWidget(self._create_vpn_status_section())
        content_layout.addWidget(self._create_activity_log_section())
        content_layout.addLayout(self._create_action_buttons_section())

        card_layout.addLayout(content_layout, stretch=1) # Allow content to take available space

        return card_widget

    def _create_info_box(self, title_text):
        box = QWidget()
        box.setObjectName("InfoBox")
        layout = QVBoxLayout(box)
        layout.setContentsMargins(12, 12, 12, 12) # p-4 approx
        layout.setSpacing(8) # mb-2 between items

        title_layout = QVBoxLayout()
        title_layout.setSpacing(4) # pb-1

        title_label = QLabel(title_text)
        title_label.setObjectName("InfoBoxTitle")
        title_layout.addWidget(title_label)

        line = QFrame()
        line.setFrameShape(QFrame.Shape.HLine)
        line.setObjectName("InfoBoxTitleLine")
        title_layout.addWidget(line)

        layout.addLayout(title_layout)
        return box, layout

    def _create_info_line(self, key, value_text):
        line_widget = QWidget()
        line_layout = QHBoxLayout(line_widget)
        line_layout.setContentsMargins(0, 0, 0, 0)
        line_layout.setSpacing(4)

        key_label = QLabel(f"{key}:")
        key_label.setObjectName("InfoKey")

        value_label = QLabel(value_text)
        value_label.setObjectName("InfoValue")
        value_label.setWordWrap(True) # Allow wrapping if needed

        line_layout.addWidget(key_label)
        line_layout.addWidget(value_label)
        line_layout.addStretch(1) # Push value highlight to the right if needed

        return line_widget

    def _create_ip_info_section(self):
        ip_section_widget = QWidget()
        ip_layout = QGridLayout(ip_section_widget)
        ip_layout.setContentsMargins(0,0,0,0)
        ip_layout.setSpacing(16) # gap-4

        # Public IP Box
        public_box, public_layout = self._create_info_box("Public IP Info")
        public_layout.addWidget(self._create_info_line("IP Address", "192.168.1.100"))
        public_layout.addWidget(self._create_info_line("Location", "USA"))
        public_layout.addStretch(1) # Push content up

        # Local IP Box
        local_box, local_layout = self._create_info_box("Local IP Info")
        local_layout.addWidget(self._create_info_line("IP Address", "10.0.0.5"))
        local_layout.addWidget(self._create_info_line("MAC Address", "00:1A:2B:3C:4D:5E"))
        local_layout.addStretch(1) # Push content up

        ip_layout.addWidget(public_box, 0, 0)
        ip_layout.addWidget(local_box, 0, 1)

        return ip_section_widget

    def _create_vpn_status_section(self):
        box = QWidget()
        box.setObjectName("InfoBox") # Reuse style
        layout = QVBoxLayout(box)
        layout.setContentsMargins(12, 12, 12, 12) # p-4
        layout.setSpacing(8)

        # Header Row (Title + Button)
        header_row = QHBoxLayout()
        header_row.setSpacing(8)

        title_label = QLabel("VPN Status")
        title_label.setObjectName("InfoBoxTitle") # Reuse style

        self.vpn_toggle_button = QPushButton("Connect") # Text updated dynamically
        self.vpn_toggle_button.setObjectName("VpnToggleButton")
        self.vpn_toggle_button.setFixedSize(100, 32) # Approx size, h-8, px-3 py-2
        self.vpn_toggle_button.setCursor(Qt.CursorShape.PointingHandCursor)
        self.vpn_toggle_button.clicked.connect(self._toggle_vpn)

        header_row.addWidget(title_label)
        header_row.addStretch(1)
        header_row.addWidget(self.vpn_toggle_button)

        layout.addLayout(header_row)

        # Line below header
        line = QFrame()
        line.setFrameShape(QFrame.Shape.HLine)
        line.setObjectName("InfoBoxTitleLine") #Reuse style
        layout.addWidget(line)

        # Status Text
        self.vpn_status_label = QLabel("Status: Disconnected") # Text updated dynamically
        self.vpn_status_label.setObjectName("VpnStatusText")
        layout.addWidget(self.vpn_status_label)

        layout.addStretch(1) # Push content up if needed

        return box

    def _create_activity_log_section(self):
        log_container = QWidget()
        log_container.setObjectName("InfoBox") # Reuse border/bg style
        log_container_layout = QVBoxLayout(log_container)
        log_container_layout.setContentsMargins(12, 12, 12, 12) # p-4
        log_container_layout.setSpacing(8)

        # Title + Line
        title_layout = QVBoxLayout()
        title_layout.setSpacing(4) # pb-1
        title_label = QLabel("Activity Log")
        title_label.setObjectName("InfoBoxTitle")
        title_layout.addWidget(title_label)
        line = QFrame()
        line.setFrameShape(QFrame.Shape.HLine)
        line.setObjectName("InfoBoxTitleLine")
        title_layout.addWidget(line)
        log_container_layout.addLayout(title_layout)

        # Scroll Area
        scroll_area = QScrollArea()
        scroll_area.setObjectName("LogScrollArea")
        scroll_area.setWidgetResizable(True)
        scroll_area.setFixedHeight(192) # h-48 * 4 (approx pixels per unit)
        scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)

        log_content_widget = QWidget() # Widget inside scroll area
        log_content_layout = QVBoxLayout(log_content_widget)
        log_content_layout.setContentsMargins(0, 0, 0, 0)
        log_content_layout.setSpacing(4) # mb-1 approx
        log_content_layout.setAlignment(Qt.AlignmentFlag.AlignTop)

        # Example Log Entries
        log_entries = [
            "> Request to server A",
            "> Data received from server B",
            "> VPN status changed",
            "> Website blocked - example.com",
            "> File downloaded - report.pdf",
            "> Another event happened here",
            "> System check initiated",
            "> User logged out",
            "> Attempted connection to blocked IP",
        ]
        for entry in log_entries:
            log_label = QLabel(entry)
            log_label.setObjectName("LogEntry")
            log_label.setWordWrap(True)
            log_content_layout.addWidget(log_label)

        scroll_area.setWidget(log_content_widget)
        log_container_layout.addWidget(scroll_area)

        return log_container


    def _create_action_buttons_section(self):
        button_layout = QHBoxLayout()
        button_layout.setContentsMargins(0,0,0,0)
        button_layout.setSpacing(8) # space-x-2 approx

        btn_start = QPushButton("Start Blocking")
        btn_start.setObjectName("ActionButtonStart")
        btn_start.setFixedHeight(32) # h-8
        btn_start.setCursor(Qt.CursorShape.PointingHandCursor)

        btn_refresh = QPushButton("Refresh")
        btn_refresh.setObjectName("ActionButtonRefresh")
        btn_refresh.setFixedHeight(32)
        btn_refresh.setCursor(Qt.CursorShape.PointingHandCursor)

        btn_export = QPushButton("Export Data")
        btn_export.setObjectName("ActionButtonExport")
        btn_export.setFixedHeight(32)
        btn_export.setCursor(Qt.CursorShape.PointingHandCursor)

        button_layout.addWidget(btn_start)
        # button_layout.addStretch(1) # Use this if you want space between buttons
        button_layout.addWidget(btn_refresh)
        # button_layout.addStretch(1)
        button_layout.addWidget(btn_export)
        # button_layout.addStretch(1) # Use this instead of space-between property

        # Add Connections (Example)
        btn_start.clicked.connect(lambda: self._show_message("Action", "Start Blocking clicked!"))
        btn_refresh.clicked.connect(lambda: self._show_message("Action", "Refresh clicked!"))
        btn_export.clicked.connect(lambda: self._show_message("Action", "Export Data clicked!"))


        return button_layout

    # --- State Handling & UI Updates ---

    def _toggle_vpn(self):
        self._vpn_connected = not self._vpn_connected
        self._update_vpn_ui()
        title = "VPN Status Changed"
        description = f"VPN is now {'Connected' if self._vpn_connected else 'Disconnected'}"
        self._show_message(title, description)


    def _update_vpn_ui(self):
        status_text = "Connected" if self._vpn_connected else "Disconnected"
        button_text = "Disconnect" if self._vpn_connected else "Connect"
        status_color = COLOR_VPN_CONNECTED if self._vpn_connected else COLOR_VPN_DISCONNECTED

        self.vpn_toggle_button.setText(button_text)
        self.vpn_status_label.setText(f"Status: {status_text}")

        # Update styles dynamically using properties
        self.vpn_toggle_button.setProperty("vpnStatus", status_text.lower())
        self.vpn_status_label.setProperty("vpnStatus", status_text.lower())

        # Re-apply styles for elements with dynamic properties
        self.style().unpolish(self.vpn_toggle_button)
        self.style().polish(self.vpn_toggle_button)
        self.style().unpolish(self.vpn_status_label)
        self.style().polish(self.vpn_status_label)

    def _show_message(self, title, description):
        # Basic replacement for the toast
        msg_box = QMessageBox(self)
        msg_box.setWindowTitle(title)
        msg_box.setText(description)
        # msg_box.setIcon(QMessageBox.Icon.Information) # Optional icon
        # Set fixed size or adjust styling if needed
        msg_box.setStyleSheet(f"""
            QMessageBox {{
                font-family: {FONT_FAMILY_MONO};
                font-size: {FONT_SIZE_SM}pt;
            }}
            QLabel {{
                 color: {COLOR_TEXT_DEFAULT};
            }}
            QPushButton {{
                background-color: {COLOR_BG_HIGHLIGHT};
                border: 1px solid {COLOR_BORDER_HIGHLIGHT};
                padding: 5px 10px;
                border-radius: 3px;
                min-width: 60px;
            }}
            QPushButton:hover {{
                background-color: {COLOR_BORDER_HIGHLIGHT}; /* Simple hover */
            }}
        """)
        msg_box.exec()

    # --- Styling (QSS) ---

    def _apply_styles(self):
        button_common_style = f"""
            color: {COLOR_TEXT_WHITE};
            font-weight: bold;
            font-size: {FONT_SIZE_XS}pt;
            border: 1px solid {COLOR_BORDER};
            border-radius: 16px; /* half of height 32px */
            padding: 5px 12px; /* Adjust for text fit */
        """

        styles = f"""
            QWidget {{
                font-family: {FONT_FAMILY_MONO};
                color: {COLOR_TEXT_DEFAULT};
            }}
            #CardWidget {{
                background-color: {COLOR_BG_CARD};
                border: 2px solid {COLOR_BORDER};
                border-radius: 12px; /* rounded-xl */
                /* Simulating shadow with border, real shadow is harder */
            }}
            #CardTitle {{
                font-size: {FONT_SIZE_LG}pt;
                font-weight: bold;
                padding-bottom: 4px; /* Add space before line */
            }}
            #HeaderLine {{
                border: none;
                border-top: 2px solid {COLOR_BORDER};
                margin-top: 8px; /* mt-2 */
                margin-bottom: 4px; /* mb-1 */
            }}

            /* --- Info Boxes --- */
            #InfoBox {{
                background-color: {COLOR_BG_SECTION};
                border: 2px solid {COLOR_BORDER};
                border-radius: 6px; /* rounded-md */
                padding: 0; /* Padding is handled by layout margins */
            }}
            #InfoBoxTitle {{
                font-size: {FONT_SIZE_SM}pt;
                font-weight: bold;
                 padding-bottom: 0px; /* Adjust spacing */
            }}
            #InfoBoxTitleLine {{
                border: none;
                border-top: 1px solid {COLOR_BORDER}; /* Thinner than header line */
                margin-top: 4px; /* pb-1 simulated */
                margin-bottom: 8px; /* mb-2 */
            }}
            #InfoKey {{
                font-size: {FONT_SIZE_XS}pt;
                line-height: 1.6; /* leading-relaxed approx */
            }}
            #InfoValue {{
                font-size: {FONT_SIZE_XS}pt;
                background-color: {COLOR_BG_HIGHLIGHT};
                border: 1px solid {COLOR_BORDER_HIGHLIGHT};
                border-radius: 3px; /* rounded */
                padding: 1px 4px; /* px-1 */
                line-height: 1.6;
            }}

            /* --- VPN Section Dynamic Styles --- */
            #VpnToggleButton {{
                {button_common_style} /* Inherit base button style */
            }}
            #VpnToggleButton[vpnStatus="connected"] {{
                background-color: {COLOR_VPN_CONNECTED};
            }}
            #VpnToggleButton[vpnStatus="connected"]:hover {{
                background-color: {COLOR_VPN_CONNECTED_HOVER};
            }}
            #VpnToggleButton[vpnStatus="disconnected"] {{
                background-color: {COLOR_VPN_DISCONNECTED};
            }}
             #VpnToggleButton[vpnStatus="disconnected"]:hover {{
                background-color: {COLOR_VPN_DISCONNECTED_HOVER};
            }}

            #VpnStatusText {{
                font-size: {FONT_SIZE_XS}pt;
                font-weight: bold;
                line-height: 1.6; /* leading-relaxed */
            }}
             #VpnStatusText[vpnStatus="connected"] {{
                 color: {COLOR_VPN_CONNECTED};
             }}
             #VpnStatusText[vpnStatus="disconnected"] {{
                 color: {COLOR_VPN_DISCONNECTED};
             }}

            /* --- Activity Log --- */
             #LogScrollArea {{
                 border: none; /* Border is on the container */
                 background-color: transparent; /* Inherit container BG */
             }}
             #LogScrollArea QWidget {{ /* Need to target inner widget for bg */
                 background-color: transparent;
             }}
             #LogEntry {{
                 font-size: {FONT_SIZE_XS}pt;
                 line-height: 1.6; /* leading-relaxed */
                 margin-bottom: 2px; /* mb-1 approx */
             }}
             /* Customize Scrollbar (Optional) */
             QScrollBar:vertical {{
                 border: 1px solid {COLOR_BORDER_HIGHLIGHT};
                 background: {COLOR_BG_HIGHLIGHT};
                 width: 10px;
                 margin: 0px 0px 0px 0px;
             }}
             QScrollBar::handle:vertical {{
                 background: {COLOR_BORDER_HIGHLIGHT};
                 min-height: 20px;
                 border-radius: 5px;
             }}
             QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {{
                 height: 0px;
                 background: none;
             }}


            /* --- Action Buttons --- */
            #ActionButtonStart {{
                {button_common_style}
                background-color: {COLOR_BUTTON_START};
            }}
             #ActionButtonStart:hover {{
                background-color: {COLOR_BUTTON_START_HOVER};
             }}
             #ActionButtonRefresh {{
                 {button_common_style}
                 background-color: {COLOR_BUTTON_REFRESH};
             }}
             #ActionButtonRefresh:hover {{
                 background-color: {COLOR_BUTTON_REFRESH_HOVER};
             }}
             #ActionButtonExport {{
                 {button_common_style}
                 background-color: {COLOR_BUTTON_EXPORT};
             }}
             #ActionButtonExport:hover {{
                 background-color: {COLOR_BUTTON_EXPORT_HOVER};
             }}
        """
        self.setStyleSheet(styles)


if __name__ == '__main__':
    app = QApplication(sys.argv)
    # You might need to experiment with font rendering hints
    # QFont.insertSubstitution(".SF NS Text", "Monospace") # Example for macOS
    # app.setFont(QFont(FONT_FAMILY_MONO)) # Set default app font (can be overridden)

    window = RetroDashboardYaakai()
    window.show()
    sys.exit(app.exec())

#dashboradpage.py 
import sys
import math
from PyQt6.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QFrame,
    QSizePolicy, QMessageBox, QSpacerItem
)
from PyQt6.QtGui import QPainter, QColor, QBrush, QPen, QFont, QFontMetrics, QPalette
from PyQt6.QtCore import Qt, QRectF, QPointF, QSize

# --- Color Palette (from Tailwind classes) ---
COLOR_BG_MAIN = "#f3f4f6"  # gray-100
COLOR_BG_CARD = "#ffffff"
COLOR_BORDER = "#000000"
COLOR_TEXT_DEFAULT = "#000000"
COLOR_TEXT_LG = "#111827" # gray-900 approx for title?
COLOR_PIE_VPN_DETECTED = "#10B981" # green-500
COLOR_PIE_VPN_NOT_DETECTED = "#F59E0B" # amber-500
COLOR_TEXT_VPN_DETECTED = "#059669" # green-600
COLOR_TEXT_VPN_NOT_DETECTED = "#D97706" # amber-600

# --- Font Sizes (Approximations) ---
FONT_SIZE_XS = 9
FONT_SIZE_SM = 10
FONT_SIZE_BASE = 11 # For labels/legend
FONT_SIZE_LG = 14 # Title
FONT_SIZE_4XL = 32 # Large numbers

FONT_FAMILY_MONO = "Consolas, Courier New, monospace"

# --- Data ---
DATA = [
    {'name': 'VPN Detected', 'value': 10},
    {'name': 'VPN Not Detected', 'value': 5},
]
COLORS = [QColor(COLOR_PIE_VPN_DETECTED), QColor(COLOR_PIE_VPN_NOT_DETECTED)]


# --- Custom Pie Chart Widget ---
class PieChartWidget(QWidget):
    def __init__(self, data, colors, parent=None):
        super().__init__(parent)
        self.data = data
        self.colors = colors
        self.total_value = sum(item['value'] for item in data)
        self.setMinimumSize(200, 200) # Minimum size for the chart
        self.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)

        widget_rect = self.rect()
        side = min(widget_rect.width(), widget_rect.height())

        # Reduce size slightly for padding and legend space
        chart_diameter = side * 0.7
        legend_height_estimate = len(self.data) * 20 + 10 # Estimate space for legend

        # Adjust vertical position if legend is below
        pie_top_margin = 20
        available_height_for_pie = widget_rect.height() - legend_height_estimate - pie_top_margin
        chart_diameter = min(chart_diameter, available_height_for_pie)
        outer_radius = chart_diameter / 2

        # Center the pie chart horizontally, position vertically
        center_x = widget_rect.width() / 2
        center_y = pie_top_margin + outer_radius # Top edge + radius
        center = QPointF(center_x, center_y)

        pie_rect = QRectF(center_x - outer_radius, center_y - outer_radius,
                          chart_diameter, chart_diameter)

        label_font = QFont(FONT_FAMILY_MONO, FONT_SIZE_SM)
        label_pen = QPen(QColor(COLOR_TEXT_DEFAULT))
        painter.setFont(label_font)
        painter.setPen(label_pen)
        fm = QFontMetrics(label_font)

        start_angle = 90 * 16  # Start at the top (Qt angles are in 1/16th degrees)
        label_radius_factor = 0.7 # How far out labels are (0.5 = center, 1.0 = edge)

        if self.total_value == 0: # Avoid division by zero
             # Draw a simple placeholder if no data
             painter.setPen(QColor(COLOR_BORDER))
             painter.setBrush(Qt.BrushStyle.NoBrush)
             painter.drawEllipse(pie_rect)
             painter.drawText(pie_rect, Qt.AlignmentFlag.AlignCenter, "No data")
             return # Skip drawing slices/legend


        # --- Draw Pie Slices and Labels ---
        for i, item in enumerate(self.data):
            if item['value'] <= 0: continue # Skip zero/negative values

            angle_fraction = item['value'] / self.total_value
            span_angle = int(angle_fraction * 360 * 16)

            # Draw Slice
            painter.setBrush(QBrush(self.colors[i % len(self.colors)]))
            painter.setPen(Qt.PenStyle.NoPen) # No border on slices for this style
            painter.drawPie(pie_rect, start_angle, span_angle)

            # Draw Label (Percentage)
            mid_angle_deg = -( (start_angle + span_angle / 2) / 16.0 ) # Degrees, adjust direction
            label_radius = outer_radius * label_radius_factor
            label_x = center.x() + label_radius * math.cos(math.radians(mid_angle_deg))
            label_y = center.y() + label_radius * math.sin(math.radians(mid_angle_deg))
            percent_text = f"{angle_fraction * 100:.0f}%"

            # Adjust text anchor based on position relative to center
            text_rect = fm.boundingRect(percent_text)
            text_point = QPointF(label_x, label_y)
            if label_x < center.x(): # Left side
                 text_point.setX(label_x - text_rect.width())

            text_point.setY(label_y - text_rect.height() / 2 + fm.ascent()/2) # Center vertically

            painter.setPen(label_pen)
            painter.drawText(text_point, percent_text)


            start_angle += span_angle

        # --- Draw Legend ---
        legend_font = QFont(FONT_FAMILY_MONO, FONT_SIZE_BASE)
        painter.setFont(legend_font)
        fm_legend = QFontMetrics(legend_font)
        legend_y_start = center_y + outer_radius + 20 # Below the pie
        legend_x_start = center_x - (outer_radius * 0.8) # Align leftish
        legend_item_height = fm_legend.height() + 4
        color_box_size = fm_legend.height() * 0.8
        text_margin = 5

        for i, item in enumerate(self.data):
            current_y = legend_y_start + i * legend_item_height

            # Check if legend goes off widget
            if current_y + legend_item_height > widget_rect.height():
                # Handle overflow: Stop drawing, or implement columns, etc.
                # For simplicity, we just stop if it overflows significantly.
                if current_y > widget_rect.height() - 5: break # Stop if already mostly off

            # Color Box
            painter.setBrush(QBrush(self.colors[i % len(self.colors)]))
            painter.setPen(Qt.PenStyle.NoPen)
            color_rect = QRectF(legend_x_start, current_y, color_box_size, color_box_size)
            painter.drawRect(color_rect)

            # Text Label
            painter.setPen(label_pen)
            text_x = legend_x_start + color_box_size + text_margin
            # Center text vertically with the color box
            text_y = current_y + (color_box_size / 2) - (fm_legend.height()/2) + fm_legend.ascent()
            painter.drawText(QPointF(text_x, text_y), item['name'])


# --- Main Dashboard Widget ---
class VPNDetectionStatsDashboardYaakai(QWidget):
    def __init__(self):
        super().__init__()
        self.data = DATA
        self.colors = COLORS
        self._init_ui()
        self._apply_styles()

    def _init_ui(self):
        self.setWindowTitle("Checkblock VPN Stats")
        self.setMinimumSize(600, 700) # Window size

        # Overall layout centering the card
        main_layout = QHBoxLayout(self)
        main_layout.addStretch(1)
        main_layout.addWidget(self._create_card())
        main_layout.addStretch(1)

        # Set overall background
        palette = self.palette()
        palette.setColor(QPalette.ColorRole.Window, QColor(COLOR_BG_MAIN))
        self.setAutoFillBackground(True)
        self.setPalette(palette)

    def _create_card(self):
        card_widget = QWidget()
        card_widget.setObjectName("CardWidget")
        card_widget.setFixedWidth(505)

        card_layout = QVBoxLayout(card_widget)
        card_layout.setContentsMargins(24, 24, 24, 24) # p-6
        card_layout.setSpacing(16) # Approximation

        # --- Header ---
        header_layout = QVBoxLayout()
        header_layout.setSpacing(8)
        header_layout.setContentsMargins(8, 0, 8, 12) # px-2 mb-3

        title_label = QLabel("checkblock")
        title_label.setObjectName("CardTitle")
        title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        header_layout.addWidget(title_label)

        line = QFrame()
        line.setFrameShape(QFrame.Shape.HLine)
        line.setObjectName("HeaderLine")
        header_layout.addWidget(line)

        # 65px empty space
        header_layout.addSpacerItem(QSpacerItem(20, 65, QSizePolicy.Policy.Minimum, QSizePolicy.Policy.Fixed))
        card_layout.addLayout(header_layout)

        # --- Pie Chart ---
        self.pie_chart_widget = PieChartWidget(self.data, self.colors)
        # Use addWidget with stretch factor 0 to prevent it taking excess vertical space
        # Or set a fixed height if preferred over the internal calculation
        chart_container_layout = QHBoxLayout() # To center if needed, or just add directly
        chart_container_layout.addWidget(self.pie_chart_widget)
        card_layout.addLayout(chart_container_layout, 1) # Give chart area stretch factor 1
        # Set an explicit height for the chart container widget if needed:
        # chart_container = QWidget()
        # chart_container.setLayout(chart_container_layout)
        # chart_container.setFixedHeight(256) # h-64 * 4 approx
        # card_layout.addWidget(chart_container)
        card_layout.addSpacing(16) # mb-4


        # --- Total Stats Text ---
        total_detections = sum(item['value'] for item in self.data)
        total_label = QLabel(f"Total number of times the vpn detection is used : {total_detections}")
        total_label.setObjectName("TotalStatsLabel")
        total_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        card_layout.addWidget(total_label)
        card_layout.addSpacing(24) # mb-6

        # --- Stat Blocks ---
        stats_layout = QHBoxLayout()
        stats_layout.setSpacing(16) # gap-4

        vpn_detected = next((item['value'] for item in self.data if item['name'] == 'VPN Detected'), 0)
        vpn_not_detected = next((item['value'] for item in self.data if item['name'] == 'VPN Not Detected'), 0)

        stats_layout.addWidget(self._create_stat_block(
            "Vpn not detected", vpn_not_detected, COLOR_TEXT_VPN_NOT_DETECTED, "not_detected"
        ))
        stats_layout.addWidget(self._create_stat_block(
            "Vpn detected", vpn_detected, COLOR_TEXT_VPN_DETECTED, "detected"
        ))

        card_layout.addLayout(stats_layout)

        card_layout.addStretch(0) # Prevent bottom elements from stretching excessively

        # Ensure card doesn't grow vertically unnecessarily if content is small
        card_widget.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Minimum)


        return card_widget

    def _create_stat_block(self, title_text, value, text_color_hex, stat_type):
        block = QWidget()
        block.setObjectName("StatBlock")
        # Add a property for dynamic styling based on type
        block.setProperty("statType", stat_type)

        layout = QVBoxLayout(block)
        layout.setContentsMargins(16, 16, 16, 16) # p-4
        layout.setSpacing(8) # Approximation

        title_label = QLabel(title_text)
        title_label.setObjectName("StatBlockTitle")
        layout.addWidget(title_label)

        line = QFrame()
        line.setFrameShape(QFrame.Shape.HLine)
        line.setObjectName("StatBlockLine")
        layout.addWidget(line)

        # Add spacing like mt-6 before the number
        layout.addSpacerItem(QSpacerItem(20, 18, QSizePolicy.Policy.Minimum, QSizePolicy.Policy.Fixed)) # mt-6 approx

        value_label = QLabel(str(value))
        value_label.setObjectName("StatBlockValue")
        value_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        # Set color dynamically or via stylesheet property selector
        value_label.setStyleSheet(f"color: {text_color_hex};") # Easiest way for this one
        layout.addWidget(value_label)

        layout.addStretch(1) # Push content up

        return block

    # --- Styling (QSS) ---
    def _apply_styles(self):
        styles = f"""
            QWidget {{
                font-family: {FONT_FAMILY_MONO};
                color: {COLOR_TEXT_DEFAULT};
            }}
            #CardWidget {{
                background-color: {COLOR_BG_CARD};
                border: 2px solid {COLOR_BORDER};
                border-radius: 12px; /* rounded-xl */
                /* Basic shadow effect using offset border - real shadow is complex */
                /* border-bottom-width: 4px; */
                /* border-right-width: 4px; */
            }}
            #CardTitle {{
                font-size: {FONT_SIZE_LG}pt;
                font-weight: bold;
                color: {COLOR_TEXT_LG};
                padding-bottom: 4px;
            }}
            #HeaderLine {{
                border: none;
                border-top: 2px solid {COLOR_BORDER};
                margin-top: 8px; /* mt-2 */
                margin-bottom: 4px; /* mb-1 */
            }}

            /* PieChartWidget styling if needed (e.g., background) */
            PieChartWidget {{
                 background-color: transparent; /* Make sure it doesn't obscure card bg*/
            }}

            #TotalStatsLabel {{
                font-size: {FONT_SIZE_XS}pt;
                font-weight: bold;
                /* mb-6 handled by layout spacing */
            }}

            #StatBlock {{
                background-color: {COLOR_BG_CARD}; /* bg-white */
                border: 2px solid {COLOR_BORDER};
                border-radius: 6px; /* rounded-md */
                /* Add a subtle inner shadow/border if needed */
                /* box-shadow: inset 0 1px 2px 0 rgba(0, 0, 0, 0.05); - hard in QSS */
            }}
            #StatBlockTitle {{
                font-size: {FONT_SIZE_SM}pt;
                font-weight: bold;
                margin-bottom: 2px; /* mb-1 */
            }}
            #StatBlockLine {{
                border: none;
                border-top: 1px solid {COLOR_BORDER}; /* border-b-2 (adjust thickness if needed) */
                margin-bottom: 4px; /* mb-2 */
            }}
            #StatBlockValue {{
                font-size: {FONT_SIZE_4XL}pt; /* text-4xl */
                font-weight: 600; /* font-semibold */
                /* color is set inline for simplicity */
                /* margin-top: 24px; mt-6 handled by layout spacing */
            }}

            /* Example using property selector (alternative to inline style for value color)
            #StatBlockValue[statType="detected"] {{ color: {COLOR_TEXT_VPN_DETECTED}; }}
            #StatBlockValue[statType="not_detected"] {{ color: {COLOR_TEXT_VPN_NOT_DETECTED}; }}
            */
        """
        self.setStyleSheet(styles)

    # --- Mock Toast ---
    def _show_message(self, title, description):
        # Basic replacement for the toast
        msg_box = QMessageBox(self)
        msg_box.setWindowTitle(title)
        msg_box.setText(description)
        msg_box.setStyleSheet(f"""
            QMessageBox {{
                font-family: {FONT_FAMILY_MONO};
                font-size: {FONT_SIZE_SM}pt;
            }}
            QLabel {{ color: {COLOR_TEXT_DEFAULT}; }}
            QPushButton {{ /* Basic button style */
                background-color: #e5e7eb; border: 1px solid #9ca3af;
                padding: 5px 10px; border-radius: 3px; min-width: 60px; }}
            QPushButton:hover {{ background-color: #d1d5db; }}
        """)
        msg_box.exec()


if __name__ == '__main__':
    app = QApplication(sys.argv)
    window = VPNDetectionStatsDashboardYaakai()
    window.show()
    sys.exit(app.exec())

#profile page .py 
import sys
from PyQt6.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
    QFrame, QComboBox, QMessageBox, QSizePolicy, QSpacerItem, QLineEdit
)
from PyQt6.QtGui import QFont, QPalette, QColor, QIcon # QIcon might be needed for dropdown arrow styling later
from PyQt6.QtCore import Qt, QSize

# --- Color Palette ---
COLOR_BG_MAIN = "#f3f4f6"  # gray-100
COLOR_BG_CARD = "#ffffff"
COLOR_BORDER = "#000000"
COLOR_BG_FIELD = "#f9fafb" # gray-50
COLOR_TEXT_DEFAULT = "#000000"
COLOR_TEXT_LG = "#111827" # gray-900 approx for title?
COLOR_TEXT_LABEL = "#1f2937" # gray-800 approx for labels
COLOR_TEXT_MUTED = "#4b5563" # gray-600 for logout link
COLOR_TEXT_LINK = "#2563eb" # blue-600
COLOR_BUTTON_EDIT_BG = "#FFD325"
COLOR_BUTTON_EDIT_HOVER = "#E6BE00"
COLOR_BUTTON_EDIT_TEXT = "#000000"
COLOR_BUTTON_DELETE_BG = "#FC0A0A"
COLOR_BUTTON_DELETE_HOVER = "#D30808"
COLOR_BUTTON_DELETE_TEXT = "#ffffff"

# --- Font Sizes ---
FONT_SIZE_XS = 9
FONT_SIZE_SM = 10
FONT_SIZE_MD = 12 # Profile title
FONT_SIZE_LG = 14 # Main title

FONT_FAMILY_MONO = "Consolas, Courier New, monospace"

# --- Mock User Data ---
INITIAL_PROFILE = {
    'username': 'username123',
    'email': 'user@example.com',
    'phone': '+1 (555) 123-4567',
    'country': 'United States',
    'userId': 'CB-USER-12345',
}

# --- Country List ---
COUNTRIES = [
    "Afghanistan", "Albania", "Algeria", "Andorra", "Angola", "Antigua and Barbuda", "Argentina", "Armenia", "Australia", "Austria",
    "Azerbaijan", "Bahamas", "Bahrain", "Bangladesh", "Barbados", "Belarus", "Belgium", "Belize", "Benin", "Bhutan",
    "Bolivia", "Bosnia and Herzegovina", "Botswana", "Brazil", "Brunei", "Bulgaria", "Burkina Faso", "Burundi", "Cabo Verde", "Cambodia",
    "Cameroon", "Canada", "Central African Republic", "Chad", "Chile", "China", "Colombia", "Comoros", "Congo (Congo-Brazzaville)", "Costa Rica",
    "Croatia", "Cuba", "Cyprus", "Czechia (Czech Republic)", "Democratic Republic of the Congo", "Denmark", "Djibouti", "Dominica", "Dominican Republic", "Ecuador",
    "Egypt", "El Salvador", "Equatorial Guinea", "Eritrea", "Estonia", "Eswatini (fmr. Swaziland)", "Ethiopia", "Fiji", "Finland", "France",
    "Gabon", "Gambia", "Georgia", "Germany", "Ghana", "Greece", "Grenada", "Guatemala", "Guinea", "Guinea-Bissau",
    "Guyana", "Haiti", "Honduras", "Hungary", "Iceland", "India", "Indonesia", "Iran", "Iraq", "Ireland",
    "Israel", "Italy", "Jamaica", "Japan", "Jordan", "Kazakhstan", "Kenya", "Kiribati", "Kuwait", "Kyrgyzstan",
    "Laos", "Latvia", "Lebanon", "Lesotho", "Liberia", "Libya", "Liechtenstein", "Lithuania", "Luxembourg", "Madagascar",
    "Malawi", "Malaysia", "Maldives", "Mali", "Malta", "Marshall Islands", "Mauritania", "Mauritius", "Mexico", "Micronesia",
    "Moldova", "Monaco", "Mongolia", "Montenegro", "Morocco", "Mozambique", "Myanmar (formerly Burma)", "Namibia", "Nauru", "Nepal",
    "Netherlands", "New Zealand", "Nicaragua", "Niger", "Nigeria", "North Korea", "North Macedonia (formerly Macedonia)", "Norway", "Oman", "Pakistan",
    "Palau", "Palestine State", "Panama", "Papua New Guinea", "Paraguay", "Peru", "Philippines", "Poland", "Portugal", "Qatar",
    "Romania", "Russia", "Rwanda", "Saint Kitts and Nevis", "Saint Lucia", "Saint Vincent and the Grenadines", "Samoa", "San Marino", "Sao Tome and Principe", "Saudi Arabia",
    "Senegal", "Serbia", "Seychelles", "Sierra Leone", "Singapore", "Slovakia", "Slovenia", "Solomon Islands", "Somalia", "South Africa",
    "South Korea", "South Sudan", "Spain", "Sri Lanka", "Sudan", "Suriname", "Sweden", "Switzerland", "Syria", "Taiwan",
    "Tajikistan", "Tanzania", "Thailand", "Timor-Leste", "Togo", "Tonga", "Trinidad and Tobago", "Tunisia", "Turkey", "Turkmenistan",
    "Tuvalu", "Uganda", "Ukraine", "United Arab Emirates", "United Kingdom", "United States", "Uruguay", "Uzbekistan", "Vanuatu", "Vatican City",
    "Venezuela", "Vietnam", "Yemen", "Zambia", "Zimbabwe"
]

# --- Main Profile Widget ---
class RetroProfilePageYaakai(QWidget):
    def __init__(self):
        super().__init__()
        # Store mutable profile data if needed for updates (like country)
        self.profile_data = INITIAL_PROFILE.copy()
        self._init_ui()
        self._apply_styles()

    def _init_ui(self):
        self.setWindowTitle("Checkblock Profile")
        self.setMinimumSize(600, 750) # Window size

        # Overall layout centering the card
        main_layout = QHBoxLayout(self)
        main_layout.addStretch(1)
        main_layout.addWidget(self._create_card())
        main_layout.addStretch(1)

        # Set overall background
        palette = self.palette()
        palette.setColor(QPalette.ColorRole.Window, QColor(COLOR_BG_MAIN))
        self.setAutoFillBackground(True)
        self.setPalette(palette)

    def _create_card(self):
        card_widget = QWidget()
        card_widget.setObjectName("CardWidget")
        card_widget.setFixedWidth(505)

        card_layout = QVBoxLayout(card_widget)
        card_layout.setContentsMargins(24, 24, 24, 24) # p-6
        card_layout.setSpacing(0) # Control spacing manually or with specific styles/spacers

        # --- Header ---
        header_layout = QVBoxLayout()
        header_layout.setSpacing(8)
        header_layout.setContentsMargins(8, 0, 8, 12) # px-2 mb-3 approx

        title_label = QLabel("checkblock")
        title_label.setObjectName("CardTitle")
        title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        header_layout.addWidget(title_label)

        line = QFrame()
        line.setFrameShape(QFrame.Shape.HLine)
        line.setObjectName("HeaderLine")
        header_layout.addWidget(line)

        # 65px empty space
        header_layout.addSpacerItem(QSpacerItem(20, 65, QSizePolicy.Policy.Minimum, QSizePolicy.Policy.Fixed))
        card_layout.addLayout(header_layout)
        card_layout.addSpacing(10) # Spacing after header block

        # --- Profile Title ---
        profile_title = QLabel("Profile")
        profile_title.setObjectName("ProfileTitle")
        profile_title.setAlignment(Qt.AlignmentFlag.AlignCenter)
        card_layout.addWidget(profile_title)
        card_layout.addSpacing(24) # mb-6

        # --- Profile Content Area ---
        card_layout.addWidget(self._create_profile_content_area())
        card_layout.addSpacing(24) # mb-6

        # --- Action Buttons ---
        action_buttons_layout = QHBoxLayout()
        action_buttons_layout.setContentsMargins(16, 0, 16, 0) # px-4 equivalent
        action_buttons_layout.setSpacing(24) # gap-6
        action_buttons_layout.setAlignment(Qt.AlignmentFlag.AlignCenter) # Center buttons horizontally

        edit_button = QPushButton("Edit profile")
        edit_button.setObjectName("EditButton")
        edit_button.setCursor(Qt.CursorShape.PointingHandCursor)
        edit_button.clicked.connect(self._handle_edit)

        delete_button = QPushButton("Delete profile")
        delete_button.setObjectName("DeleteButton")
        delete_button.setCursor(Qt.CursorShape.PointingHandCursor)
        delete_button.clicked.connect(self._handle_delete)

        action_buttons_layout.addWidget(edit_button)
        action_buttons_layout.addWidget(delete_button)
        card_layout.addLayout(action_buttons_layout)
        card_layout.addSpacing(24) # mb-6

        # --- Logout Link ---
        logout_button = QPushButton("Not this account? logout")
        logout_button.setObjectName("LogoutLink")
        logout_button.setCursor(Qt.CursorShape.PointingHandCursor)
        logout_button.clicked.connect(self._handle_logout)
        card_layout.addWidget(logout_button, alignment=Qt.AlignmentFlag.AlignCenter)

        card_layout.addStretch(1) # Push content up if window is tall

        # Set fixed size policy vertically if content is small
        card_widget.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.MinimumExpanding)


        return card_widget

    def _create_profile_content_area(self):
        content_area = QWidget()
        content_area.setObjectName("ProfileContentArea")

        layout = QVBoxLayout(content_area)
        layout.setContentsMargins(16, 16, 16, 16) # p-4
        layout.setSpacing(16) # Consistent spacing between items (mb-4)

        # --- Username ---
        layout.addWidget(self._create_display_field("User name:", self.profile_data['username']))

        # --- Phone ---
        layout.addWidget(self._create_display_field("Registered phone number:", self.profile_data['phone']))

        # --- Email ---
        layout.addWidget(self._create_display_field("Registered email-id:", self.profile_data['email']))

        # --- Country / User ID Row ---
        country_user_row = QHBoxLayout()
        country_user_row.setSpacing(16) # gap-4

        # Country Column
        country_col = QVBoxLayout()
        country_col.setSpacing(4) # mb-1 between label and widget
        country_label = QLabel("country / Region")
        country_label.setObjectName("FieldLabel")
        self.country_combo = QComboBox()
        self.country_combo.setObjectName("CountryComboBox")
        self.country_combo.addItems(COUNTRIES)
        self.country_combo.setCurrentText(self.profile_data['country']) # Set initial value
        self.country_combo.currentTextChanged.connect(self._handle_country_change)
        self.country_combo.setCursor(Qt.CursorShape.PointingHandCursor) # Indicate it's interactive

        country_col.addWidget(country_label)
        country_col.addWidget(self.country_combo)
        country_user_row.addLayout(country_col, stretch=1) # Give equal space (flex-1)

        # User ID Column
        user_id_col = QVBoxLayout()
        user_id_col.setSpacing(4)
        user_id_label = QLabel("user ID")
        user_id_label.setObjectName("FieldLabel")
        user_id_display = self._create_display_field_widget(self.profile_data['userId'])

        user_id_col.addWidget(user_id_label)
        user_id_col.addWidget(user_id_display)
        country_user_row.addLayout(user_id_col, stretch=1) # Give equal space

        layout.addLayout(country_user_row) # Add the row layout

        # --- Change Password Link ---
        change_password_button = QPushButton("Change Password")
        change_password_button.setObjectName("ChangePasswordLink")
        change_password_button.setCursor(Qt.CursorShape.PointingHandCursor)
        change_password_button.clicked.connect(self._handle_change_password)
        layout.addWidget(change_password_button, alignment=Qt.AlignmentFlag.AlignCenter) # mb-2 handled by overall spacing

        return content_area

    # Helper to create the Label + styled Display Widget structure
    def _create_display_field(self, label_text, value_text):
        container = QWidget()
        layout = QVBoxLayout(container)
        layout.setContentsMargins(0,0,0,0)
        layout.setSpacing(4) # mb-1 between label and field

        label = QLabel(label_text)
        label.setObjectName("FieldLabel")

        value_widget = self._create_display_field_widget(value_text)

        layout.addWidget(label)
        layout.addWidget(value_widget)

        return container

    # Helper to create just the styled display widget (QLabel)
    def _create_display_field_widget(self, value_text):
        value_label = QLabel(value_text)
        value_label.setObjectName("DisplayField")
        value_label.setAlignment(Qt.AlignmentFlag.AlignVCenter | Qt.AlignmentFlag.AlignLeft)
        value_label.setWordWrap(False) # Prevent wrapping
        # Elide text if it overflows (like text-ellipsis)
        fm = value_label.fontMetrics()
        elided_text = fm.elidedText(value_text, Qt.TextElideMode.ElideRight, value_label.width() - 10) # Adjust width if needed
        value_label.setText(elided_text)
        # TODO: Consider connecting a resize event to re-elide text if needed, complex. Usually fixed width is ok.
        value_label.setToolTip(value_text) # Show full text on hover

        return value_label

    # --- Signal Handlers ---
    def _handle_edit(self):
        self._show_toast("Edit Profile", "Edit profile action triggered.")

    def _handle_delete(self):
        reply = QMessageBox.question(self, 'Confirm Delete',
                                     'Are you sure you want to delete your profile? This action cannot be undone.',
                                     QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                                     QMessageBox.StandardButton.No) # Default to No
        if reply == QMessageBox.StandardButton.Yes:
            self._show_toast("Delete Profile", "Profile delete requested!") # Add variant="destructive" if you style QMessageBox

    def _handle_change_password(self):
        self._show_toast("Change Password", "Change password action triggered.")

    def _handle_logout(self):
        self._show_toast("Logout", "Logout action triggered.")

    def _handle_country_change(self, new_country):
        self.profile_data['country'] = new_country
        print(f"Country changed to: {new_country}") # For debugging
        # No visual update needed here unless other parts depend on this

    # --- Mock Toast ---
    def _show_toast(self, title, description, variant="default"):
         # Basic replacement for the toast
        msg_box = QMessageBox(self) # Parent to self
        msg_box.setWindowTitle(title)
        msg_box.setText(description)

        # Minimal styling for the messagebox itself
        msg_box.setStyleSheet(f"""
            QMessageBox {{
                font-family: {FONT_FAMILY_MONO};
                font-size: {FONT_SIZE_SM}pt;
            }}
            QLabel {{ /* Text inside */
                 color: {COLOR_TEXT_DEFAULT};
                 font-size: {FONT_SIZE_SM}pt; /* Ensure text size */
            }}
            QPushButton {{ /* OK button */
                background-color: #e5e7eb;
                border: 1px solid #9ca3af;
                padding: 5px 15px;
                border-radius: 3px;
                min-width: 60px;
                font-size: {FONT_SIZE_SM}pt;
            }}
            QPushButton:hover {{
                background-color: #d1d5db;
            }}
         """)

        # You could add icons based on variant if needed
        # if variant == "destructive":
        #     msg_box.setIcon(QMessageBox.Icon.Warning)
        # else:
        #     msg_box.setIcon(QMessageBox.Icon.Information)

        msg_box.exec()


    # --- Styling (QSS) ---
    def _apply_styles(self):
        styles = f"""
            QWidget {{
                font-family: {FONT_FAMILY_MONO};
                color: {COLOR_TEXT_DEFAULT};
            }}
            #CardWidget {{
                background-color: {COLOR_BG_CARD};
                border: 2px solid {COLOR_BORDER};
                border-radius: 12px; /* rounded-xl */
                /* box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); صعب في QSS */
            }}
            #CardTitle {{
                font-size: {FONT_SIZE_LG}pt;
                font-weight: bold;
                color: {COLOR_TEXT_LG};
                padding-bottom: 4px;
            }}
            #HeaderLine {{
                border: none;
                border-top: 2px solid {COLOR_BORDER};
                margin-top: 8px; /* mt-2 */
                margin-bottom: 4px; /* mb-1 */
            }}
            #ProfileTitle {{
                font-size: {FONT_SIZE_MD}pt;
                font-weight: 600; /* font-semibold */
                color: {COLOR_TEXT_LG};
                 /* mb-6 handled by layout spacing */
            }}
            #ProfileContentArea {{
                background-color: {COLOR_BG_CARD}; /* bg-white */
                border: 2px solid {COLOR_BORDER};
                border-radius: 6px; /* rounded-md */
                 /* padding is handled by layout margins */
                 /* mb-6 handled by layout spacing */
            }}
            #FieldLabel {{
                font-size: {FONT_SIZE_SM}pt;
                font-weight: bold;
                color: {COLOR_TEXT_LABEL};
                /* mb-1 handled by layout spacing */
            }}
            #DisplayField {{
                background-color: {COLOR_BG_FIELD};
                border: 1px solid {COLOR_BORDER}; /* Black border */
                border-radius: 4px; /* rounded */
                font-size: {FONT_SIZE_SM}pt;
                min-height: 26px; /* Approx h-9 (36px), adjust padding */
                max-height: 26px;
                padding: 4px 8px; /* px-3 py-1 approx */
                color: {COLOR_TEXT_DEFAULT};
                /* overflow/ellipsis handled in Python code */
            }}

            #CountryComboBox {{
                background-color: {COLOR_BG_FIELD};
                border: 1px solid {COLOR_BORDER};
                border-radius: 4px;
                font-size: {FONT_SIZE_SM}pt;
                min-height: 26px;
                max-height: 26px;
                padding: 4px 8px;
                /* Styling the dropdown arrow is complex and platform-dependent */
                /* appearance: none; - Not directly mappable */
            }}
            #CountryComboBox::drop-down {{
                subcontrol-origin: padding;
                subcontrol-position: top right;
                width: 15px;
                border-left-width: 1px;
                border-left-color: {COLOR_BORDER};
                border-left-style: solid;
                border-top-right-radius: 3px;
                border-bottom-right-radius: 3px;
            }}
             #CountryComboBox::down-arrow {{
                 /* You can use an image for a custom arrow */
                 /* image: url(path/to/down_arrow.png); */
                 width: 7px;
                 height: 7px;
                 /* Basic triangle rendering: */
                 /* border: 3px solid transparent; */
                 /* border-top-color: {COLOR_TEXT_DEFAULT}; */
                 /* margin: auto; */
            }}
            #CountryComboBox:focus {{
                 border: 1px solid {COLOR_TEXT_LINK}; /* Mimic focus ring */
            }}

            #ChangePasswordLink {{
                font-size: {FONT_SIZE_SM}pt;
                font-weight: 300; /* font-light */
                color: {COLOR_TEXT_LINK};
                text-decoration: none; /* No underline by default */
                border: none;
                background-color: transparent;
                padding: 2px; /* Minimal padding */
                /* mb-2 handled by layout spacing */
            }}
            #ChangePasswordLink:hover {{
                text-decoration: underline;
            }}

            /* Action Buttons Base Style */
            #EditButton, #DeleteButton {{
                font-weight: bold;
                font-size: {FONT_SIZE_XS}pt; /* text-xs */
                border: 1px solid {COLOR_BORDER};
                border-radius: 20px; /* rounded-full (half of height approx) */
                padding: 8px 24px; /* py-2 px-6 */
                min-height: 24px; /* Approx h-10 (40px) including padding/border */
                max-height: 24px;
                 /* transition: background-color 0.15s ease-in-out; - Not possible in QSS */
                /* shadow-sm - Not directly possible */
            }}
            /* Edit Button Specific */
            #EditButton {{
                background-color: {COLOR_BUTTON_EDIT_BG};
                color: {COLOR_BUTTON_EDIT_TEXT};
            }}
            #EditButton:hover {{
                background-color: {COLOR_BUTTON_EDIT_HOVER};
            }}
            /* Delete Button Specific */
            #DeleteButton {{
                 background-color: {COLOR_BUTTON_DELETE_BG};
                 color: {COLOR_BUTTON_DELETE_TEXT};
            }}
             #DeleteButton:hover {{
                 background-color: {COLOR_BUTTON_DELETE_HOVER};
             }}

            #LogoutLink {{
                 font-size: {FONT_SIZE_SM}pt;
                 font-weight: 300; /* font-light */
                 color: {COLOR_TEXT_MUTED};
                 text-decoration: none;
                 border: none;
                 background-color: transparent;
                 padding: 2px;
            }}
            #LogoutLink:hover {{
                 text-decoration: underline;
            }}
        """
        self.setStyleSheet(styles)

if __name__ == '__main__':
    app = QApplication(sys.argv)
    window = RetroProfilePageYaakai()
    window.show()
    sys.exit(app.exec())

#loginpage.py 

import sys
from PyQt6.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
    QFrame, QComboBox, QMessageBox, QSizePolicy, QSpacerItem, QLineEdit
)
from PyQt6.QtGui import QFont, QPalette, QColor, QStandardItemModel, QStandardItem
from PyQt6.QtCore import Qt, QSize

# --- Color Palette ---
COLOR_BG_MAIN = "#f3f4f6"  # gray-100
COLOR_BG_CARD = "#ffffff"
COLOR_BORDER = "#000000"
COLOR_BG_FIELD = "#f9fafb"  # gray-50
COLOR_TEXT_DEFAULT = "#000000"
COLOR_TEXT_LG = "#111827"  # gray-900 approx for title?
COLOR_TEXT_LABEL = "#1f2937"  # gray-800 approx for labels
COLOR_TEXT_PLACEHOLDER = "#9ca3af"  # gray-400
COLOR_BUTTON_SUBMIT_BG = "#FFD325"
COLOR_BUTTON_SUBMIT_HOVER = "#E6BE00"
COLOR_BUTTON_SUBMIT_TEXT = "#000000"

# --- Font Sizes ---
FONT_SIZE_XS = 9
FONT_SIZE_SM = 10
FONT_SIZE_MD = 12  # Login title
FONT_SIZE_LG = 14  # Main title

FONT_FAMILY_MONO = "Consolas, Courier New, monospace"

# --- Countries Data ---
# Store as list of dictionaries for potential future use of code/dial_code
COUNTRIES_DATA = [
    {'name': 'United States', 'code': 'US', 'dial_code': '+1'},
    {'name': 'Canada', 'code': 'CA', 'dial_code': '+1'},
    {'name': 'India', 'code': 'IN', 'dial_code': '+91'},
    {'name': 'United Kingdom', 'code': 'GB', 'dial_code': '+44'},
    {'name': 'Germany', 'code': 'DE', 'dial_code': '+49'},
    {'name': 'France', 'code': 'FR', 'dial_code': '+33'},
    {'name': 'Australia', 'code': 'AU', 'dial_code': '+61'},
    {'name': 'Brazil', 'code': 'BR', 'dial_code': '+55'},
    {'name': 'Japan', 'code': 'JP', 'dial_code': '+81'},
    {'name': 'South Africa', 'code': 'ZA', 'dial_code': '+27'},
]
# For display in ComboBox, format like React example
COUNTRY_DISPLAY_LIST = [
                           "Select your country",  # Placeholder text
                       ] + [f"{c['name']} ({c['code']})" for c in COUNTRIES_DATA]
# Simple mapping from display text back to country name (if needed, e.g., for submission)
COUNTRY_NAME_MAP = {f"{c['name']} ({c['code']})": c['name'] for c in COUNTRIES_DATA}


# --- Main Login Widget ---
class LoginYaakaiAccount(QWidget):
    def __init__(self):
        super().__init__()
        self._init_ui()
        self._apply_styles()

    def _init_ui(self):
        self.setWindowTitle("Checkblock Login")
        self.setMinimumSize(600, 650)  # Adjusted window size

        # Overall layout centering the card
        main_layout = QHBoxLayout(self)
        main_layout.addStretch(1)
        main_layout.addWidget(self._create_card())
        main_layout.addStretch(1)

        # Set overall background
        palette = self.palette()
        palette.setColor(QPalette.ColorRole.Window, QColor(COLOR_BG_MAIN))
        self.setAutoFillBackground(True)
        self.setPalette(palette)

    def _create_card(self):
        card_widget = QWidget()
        card_widget.setObjectName("CardWidget")
        card_widget.setFixedWidth(505)

        card_layout = QVBoxLayout(card_widget)
        card_layout.setContentsMargins(24, 24, 24, 24)  # p-6
        card_layout.setSpacing(0)  # Control spacing via spacers or item margins

        # --- Header ---
        header_layout = QVBoxLayout()
        header_layout.setSpacing(8)
        header_layout.setContentsMargins(8, 0, 8, 12)  # px-2 mb-3 approx

        title_label = QLabel("checkblock")
        title_label.setObjectName("CardTitle")
        title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        header_layout.addWidget(title_label)

        line = QFrame()
        line.setFrameShape(QFrame.Shape.HLine)
        line.setObjectName("HeaderLine")
        header_layout.addWidget(line)

        # 65px empty space
        header_layout.addSpacerItem(QSpacerItem(20, 65, QSizePolicy.Policy.Minimum, QSizePolicy.Policy.Fixed))
        card_layout.addLayout(header_layout)
        card_layout.addSpacing(10)

        # --- Login Title ---
        login_title = QLabel("Login to your yaakai account")
        login_title.setObjectName("LoginTitle")
        login_title.setAlignment(Qt.AlignmentFlag.AlignCenter)
        card_layout.addWidget(login_title)
        card_layout.addSpacing(24)  # mb-6

        # --- Form Area ---
        form_layout = QVBoxLayout()
        form_layout.setSpacing(16)  # space-y-4

        # Email
        form_layout.addLayout(self._create_input_field(
            label_text="Email ID :",
            input_object_name="EmailInput",
            placeholder="user@example.com",
            is_password=False
        ))

        # Password
        form_layout.addLayout(self._create_input_field(
            label_text="Password :",
            input_object_name="PasswordInput",
            placeholder="********",
            is_password=True
        ))

        # Country
        form_layout.addLayout(self._create_country_field())

        # Phone
        form_layout.addLayout(self._create_input_field(
            label_text="Phone number :",
            input_object_name="PhoneInput",
            placeholder="+1 (555) 123-4567",
            is_password=False,
            input_type="tel"  # Informative, QLineEdit handles it as text
        ))

        card_layout.addLayout(form_layout)
        # Add extra space before the button (pt-4 equivalent = 16px)
        # The form layout already has 16px spacing, so add it here
        card_layout.addSpacing(16)

        # --- Submit Button ---
        submit_button = QPushButton("Login to your account")
        submit_button.setObjectName("SubmitButton")
        submit_button.setCursor(Qt.CursorShape.PointingHandCursor)
        submit_button.clicked.connect(self._handle_login)
        card_layout.addWidget(submit_button)

        card_layout.addStretch(1)  # Push elements up

        card_widget.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Minimum)

        return card_widget

    # Helper for Label + QLineEdit
    def _create_input_field(self, label_text, input_object_name, placeholder, is_password=False, input_type="text"):
        layout = QVBoxLayout()
        layout.setSpacing(4)  # mb-1 between label and input

        label = QLabel(label_text)
        label.setObjectName("FieldLabel")
        layout.addWidget(label)

        line_edit = QLineEdit()
        line_edit.setObjectName(input_object_name)
        line_edit.setPlaceholderText(placeholder)
        if is_password:
            line_edit.setEchoMode(QLineEdit.EchoMode.Password)

        # Store reference for easy access in _handle_login
        setattr(self, f"{input_object_name.lower()}_field", line_edit)

        layout.addWidget(line_edit)
        return layout

    # Helper specific for Country ComboBox field
    def _create_country_field(self):
        layout = QVBoxLayout()
        layout.setSpacing(4)

        label = QLabel("Country / region :")
        label.setObjectName("FieldLabel")
        layout.addWidget(label)

        self.country_combo = QComboBox()
        self.country_combo.setObjectName("CountryComboBox")

        # Use a model to properly handle placeholder appearance and disabling
        model = QStandardItemModel()

        # Add placeholder item
        placeholder_item = QStandardItem(COUNTRY_DISPLAY_LIST[0])
        placeholder_item.setEnabled(False)  # Make it non-selectable
        placeholder_item.setData(QColor(COLOR_TEXT_PLACEHOLDER), Qt.ItemDataRole.ForegroundRole)  # Style it gray
        model.appendRow(placeholder_item)

        # Add actual country items
        for country_display_text in COUNTRY_DISPLAY_LIST[1:]:
            item = QStandardItem(country_display_text)
            model.appendRow(item)

        self.country_combo.setModel(model)
        self.country_combo.setCurrentIndex(0)  # Start with placeholder selected
        self.country_combo.setCursor(Qt.CursorShape.PointingHandCursor)

        layout.addWidget(self.country_combo)
        return layout

    # --- Signal Handlers ---
    def _handle_login(self):
        email = self.emailinput_field.text().strip()
        password = self.passwordinput_field.text()  # Keep password as is
        country_index = self.country_combo.currentIndex()
        country_display_text = self.country_combo.currentText()  # Text like "United States (US)"
        phone = self.phoneinput_field.text().strip()

        # Get the actual country name (without code), handling the placeholder
        country_name = ""
        if country_index != 0:  # Not the placeholder
            country_name = COUNTRY_NAME_MAP.get(country_display_text, "")  # Lookup name from display text

        # --- Validation ---
        if not email or not password:
            self._show_toast("Missing Information", "Please enter both email and password.", variant="destructive")
            return
        # Check if placeholder is selected (index 0)
        if country_index == 0:
            self._show_toast("Missing Information", "Please select your country.", variant="destructive")
            return

        # If validation passes
        self._show_toast("Login Attempt", f"Email: {email}\nCountry: {country_name}\nPhone: {phone}")
        print(f"Login credentials: Email={email}, Password=***, Country={country_name}, Phone={phone}")
        # Here you would typically send the data to a backend/API

    # --- Mock Toast ---
    def _show_toast(self, title, description, variant="default"):
        msg_box = QMessageBox(self)
        msg_box.setWindowTitle(title)
        msg_box.setText(description)

        # Minimal styling for the messagebox itself
        msg_box.setStyleSheet(f"""
            QMessageBox {{
                font-family: {FONT_FAMILY_MONO};
                font-size: {FONT_SIZE_SM}pt;
            }}
            QLabel {{ /* Text inside */
                 color: {COLOR_TEXT_DEFAULT};
                 font-size: {FONT_SIZE_SM}pt;
            }}
            QPushButton {{ /* OK button */
                background-color: #e5e7eb;
                border: 1px solid {COLOR_BORDER}; /* Match theme border */
                padding: 5px 15px;
                border-radius: 12px; /* Rounded */
                min-width: 60px;
                font-size: {FONT_SIZE_SM}pt;
                font-weight: bold;
            }}
            QPushButton:hover {{
                background-color: #d1d5db;
            }}
         """)

        if variant == "destructive":
            msg_box.setIcon(QMessageBox.Icon.Warning)
        else:
            msg_box.setIcon(QMessageBox.Icon.Information)

        msg_box.exec()

    # --- Styling (QSS) ---
    def _apply_styles(self):
        # Style sheet using constants defined above
        styles = f"""
            QWidget {{
                font-family: {FONT_FAMILY_MONO};
                color: {COLOR_TEXT_DEFAULT};
            }}
            #CardWidget {{
                background-color: {COLOR_BG_CARD};
                border: 2px solid {COLOR_BORDER};
                border-radius: 12px; /* rounded-xl */
            }}
            #CardTitle {{
                font-size: {FONT_SIZE_LG}pt;
                font-weight: bold;
                color: {COLOR_TEXT_LG};
                padding-bottom: 4px;
            }}
            #HeaderLine {{
                border: none;
                border-top: 2px solid {COLOR_BORDER};
                margin-top: 8px; /* mt-2 */
                margin-bottom: 4px; /* mb-1 */
            }}
            #LoginTitle {{
                font-size: {FONT_SIZE_MD}pt;
                font-weight: 600; /* font-semibold */
                color: {COLOR_TEXT_LG};
                 /* mb-6 handled by layout spacing */
            }}
            #FieldLabel {{
                font-size: {FONT_SIZE_SM}pt;
                font-weight: bold;
                color: {COLOR_TEXT_LABEL};
                /* mb-1 handled by layout spacing */
            }}

            /* Input Fields (QLineEdit) */
            QLineEdit {{
                background-color: {COLOR_BG_FIELD};
                border: 1px solid {COLOR_BORDER};
                border-radius: 4px; /* rounded */
                font-size: {FONT_SIZE_SM}pt;
                /* Adjusted height and padding for h-10 */
                min-height: 28px; 
                max-height: 28px;
                padding: 5px 12px; /* px-3 py-2 approx */
                color: {COLOR_TEXT_DEFAULT};
            }}
             QLineEdit:focus {{
                 border: 1px solid #4338ca; /* Simulate ring like ring-black - using a dark indigo */
             }}
             QLineEdit::placeholder {{
                 color: {COLOR_TEXT_PLACEHOLDER};
                 font-style: normal; /* Ensure placeholder isn't italicized by default */
                 font-size: {FONT_SIZE_SM}pt;
             }}

            /* Country ComboBox */
            #CountryComboBox {{
                background-color: {COLOR_BG_FIELD};
                border: 1px solid {COLOR_BORDER};
                border-radius: 4px;
                font-size: {FONT_SIZE_SM}pt;
                /* Match QLineEdit height/padding */
                min-height: 28px;
                max-height: 28px;
                padding: 5px 12px;
                 /* appearance: none; - Not directly mappable */
            }}
            /* Ensure combo box text color isn't placeholder color unless it's index 0 */
            #CountryComboBox {{ color: {COLOR_TEXT_DEFAULT}; }} /* Default text color */
            #CountryComboBox:!enabled {{ color: {COLOR_TEXT_PLACEHOLDER}; }} /* Might style if disabled */

            #CountryComboBox QAbstractItemView {{ /* Style dropdown list */
                background-color: {COLOR_BG_CARD};
                border: 1px solid {COLOR_BORDER};
                font-size: {FONT_SIZE_SM}pt;
                padding: 4px;
                outline: 0px; /* Remove focus outline around list */
                 selection-background-color: #e5e7eb; /* bg-gray-100 on hover/select */
                 selection-color: {COLOR_TEXT_DEFAULT}; /* Ensure text readable on selection*/
            }}
             #CountryComboBox QAbstractItemView::item {{
                 padding: 5px 10px; /* Item padding */
                 min-height: 25px;
             }}
             /* Placeholder item styling is now handled via the model's ForegroundRole */

            #CountryComboBox::drop-down {{
                subcontrol-origin: padding;
                subcontrol-position: top right;
                width: 20px;
                border-left-width: 1px;
                border-left-color: {COLOR_BORDER};
                border-left-style: solid;
                border-top-right-radius: 3px;
                border-bottom-right-radius: 3px;
            }}
             #CountryComboBox::down-arrow {{
                 /* Leaving default arrow for simplicity */
                 /* image: url(path/to/arrow.svg); */
                 width: 10px;
                 height: 10px;
             }}
            #CountryComboBox:focus {{ /* Focus on the combo box itself */
                 border: 1px solid #4338ca; /* Match QLineEdit focus */
            }}

            /* Submit Button */
            #SubmitButton {{
                background-color: {COLOR_BUTTON_SUBMIT_BG};
                color: {COLOR_BUTTON_SUBMIT_TEXT};
                font-weight: bold;
                font-size: {FONT_SIZE_SM}pt; /* text-sm */
                border: 1px solid {COLOR_BORDER};
                border-radius: 20px; /* rounded-full (approx half of height) */
                padding: 8px 24px; /* py-2 px-6 */
                /* Match h-10 (40px) sizing */
                min-height: 24px; 
                max-height: 24px; 
                /* transition/shadow ignored */
            }}
            #SubmitButton:hover {{
                background-color: {COLOR_BUTTON_SUBMIT_HOVER};
            }}
        """
        self.setStyleSheet(styles)


if __name__ == '__main__':
    app = QApplication(sys.argv)
    window = LoginYaakaiAccount()
    window.show()
    sys.exit(app.exec())

#navigationbar.py

import sys
from PyQt6.QtWidgets import (
    QApplication, QWidget, QPushButton, QHBoxLayout, QSizePolicy, QFrame,
    QVBoxLayout
)
from PyQt6.QtGui import QFont, QPalette, QColor, QPainter, QPen, QBrush
from PyQt6.QtCore import Qt, QRect, QPropertyAnimation, QEasingCurve, QSize, QTimer

# --- Constants ---
COLOR_BG_MAIN = "#f3f4f6"  # gray-100
COLOR_NAV_BG = "#f9fafb"  # gray-50 (navbar container bg)
COLOR_HIGHLIGHT_BG = "#FFD325"  # yellow for highlight
COLOR_BORDER = "#000000"
COLOR_TEXT_SELECTED = "#000000"
COLOR_TEXT_NORMAL = "#374151"
COLOR_TEXT_HOVER = "#000000"
COLOR_BUTTON_HOVER_BG = "#e5e7eb"  # gray-200
COLOR_ROUNDED_RECT_BORDER = "#000000"

FONT_SIZE_XS = 9
FONT_FAMILY_MONO = "Consolas, Courier New, monospace"

ANIMATION_DURATION = 300
OUTER_PADDING = 50
ROUNDED_RECT_RADIUS = 50
BORDER_WIDTH = 1

NAV_ITEMS = [
    {'id': 'main', 'label': 'Main page'},
    {'id': 'dashboard', 'label': 'Dashboard'},
    {'id': 'profile', 'label': 'Profile'},
]


class RoundedBorderWidget(QWidget):
    """Widget that draws a rounded rectangle border around its contents"""

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)

        pen = QPen(QColor(COLOR_ROUNDED_RECT_BORDER), BORDER_WIDTH)
        painter.setPen(pen)
        painter.setBrush(QBrush(Qt.BrushStyle.NoBrush))  # No fill

        # Draw rounded rectangle matching the widget's size
        rect = self.rect().adjusted(1, 1, -1, -1)  # Adjust to prevent clipping
        painter.drawRoundedRect(rect, ROUNDED_RECT_RADIUS, ROUNDED_RECT_RADIUS)


class NavigationBarYaakai(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self._current_page_id = NAV_ITEMS[0]['id']
        self._buttons = {}
        self._animation = None

        # Store hover state
        self._hover_button = None

        self._init_ui()
        self._apply_styles()

        QTimer.singleShot(0, self._initial_highlight_position)

    def _init_ui(self):
        self.setObjectName("NavBarContainer")
        self.setFixedHeight(42)

        # Enable mouse tracking for hover effects
        self.setMouseTracking(True)
        for child in self.findChildren(QWidget):
            child.setMouseTracking(True)

        self.layout = QHBoxLayout(self)
        self.layout.setContentsMargins(4, 4, 4, 4)
        self.layout.setSpacing(4)

        # Highlight widget for selected button
        self.highlight_widget = QFrame(self)
        self.highlight_widget.setObjectName("Highlight")
        self.highlight_widget.lower()

        # Hover highlight widget
        self.hover_widget = QFrame(self)
        self.hover_widget.setObjectName("HoverHighlight")
        self.hover_widget.lower()
        self.hover_widget.hide()

        # Create buttons
        for item in NAV_ITEMS:
            button = QPushButton(item['label'])
            button.setObjectName("NavButton")
            button.setProperty("navId", item['id'])
            button.setCursor(Qt.CursorShape.PointingHandCursor)
            button.setSizePolicy(QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Expanding)

            # Install event filters for hover detection
            button.installEventFilter(self)

            button.clicked.connect(self._handle_button_click)
            self.layout.addWidget(button)
            self._buttons[item['id']] = button

        self._update_button_styles()

    def eventFilter(self, obj, event):
        # Handle hover events
        if event.type() == event.Type.Enter and obj in self._buttons.values():
            self._handle_hover_enter(obj)
        elif event.type() == event.Type.Leave and obj == self._hover_button:
            self._handle_hover_leave()
        return super().eventFilter(obj, event)

    def _handle_hover_enter(self, button):
        # Skip if this button is already selected
        if button.property("navId") == self._current_page_id:
            return

        self._hover_button = button
        self._update_hover_widget_position(button)
        self._animate_hover_widget(show=True)

    def _handle_hover_leave(self):
        self._animate_hover_widget(show=False)
        self._hover_button = None

    def _update_hover_widget_position(self, button):
        target_geom = self._get_target_geometry(button)
        if target_geom:
            self.hover_widget.setGeometry(target_geom)

    def _animate_hover_widget(self, show=True):
        if show:
            # Show immediately if not visible
            if not self.hover_widget.isVisible():
                self.hover_widget.show()
                self.hover_widget.raise_()
                self.hover_widget.lower()

            # Animate opacity for smooth appearance
            self.hover_widget.setStyleSheet("""
                QFrame#HoverHighlight {
                    background-color: rgba(229, 231, 235, 200);
                    border: none;
                }
            """)
        else:
            # Simply hide (no animation for leaving currently)
            self.hover_widget.hide()

    def _handle_button_click(self):
        sender_button = self.sender()
        if not sender_button:
            return

        new_page_id = sender_button.property("navId")
        if new_page_id and new_page_id != self._current_page_id:
            self._current_page_id = new_page_id
            self._update_button_styles()
            self._animate_highlight()
            print(f"Navigated to: {self._current_page_id}")

    def _update_button_styles(self):
        for page_id, button in self._buttons.items():
            is_selected = (page_id == self._current_page_id)
            button.setProperty("selected", is_selected)
            self.style().unpolish(button)
            self.style().polish(button)

    def _initial_highlight_position(self):
        if not self.isVisible() or self._current_page_id not in self._buttons:
            return

        target_button = self._buttons[self._current_page_id]
        if target_button.width() <= 1:
            QTimer.singleShot(10, self._initial_highlight_position)
            return

        target_geom = self._get_target_geometry(target_button)
        if target_geom:
            self.highlight_widget.setGeometry(target_geom)
            self.highlight_widget.show()
            self.highlight_widget.raise_()
            self.highlight_widget.lower()

    def _get_target_geometry(self, target_button: QPushButton) -> QRect:
        if not target_button or target_button.width() <= 1:
            return QRect()

        button_pos = target_button.pos()
        button_size = target_button.size()

        # Calculate highlight rectangle that perfectly matches button bounds
        target_height = self.height() - self.layout.contentsMargins().top() - self.layout.contentsMargins().bottom()
        target_width = button_size.width()
        target_x = button_pos.x()
        target_y = self.layout.contentsMargins().top()

        return QRect(int(target_x), int(target_y), int(target_width), int(target_height))

    def _animate_highlight(self):
        if self._current_page_id not in self._buttons:
            return

        target_button = self._buttons[self._current_page_id]
        target_geom = self._get_target_geometry(target_button)

        if target_geom.isNull():
            return

        self.highlight_widget.show()
        self.highlight_widget.raise_()
        self.highlight_widget.lower()

        if self._animation and self._animation.state() == QPropertyAnimation.State.Running:
            self._animation.stop()

        self._animation = QPropertyAnimation(self.highlight_widget, b"geometry")
        self._animation.setDuration(ANIMATION_DURATION)
        self._animation.setStartValue(self.highlight_widget.geometry())
        self._animation.setEndValue(target_geom)
        self._animation.setEasingCurve(QEasingCurve.Type.InOutCubic)
        self._animation.start()

    def _apply_styles(self):
        container_radius = self.height() // 2
        inner_radius = container_radius - (self.layout.contentsMargins().top()) - 1

        styles = f"""
            /* Main container styles */
            #NavBarContainer {{
                background-color: {COLOR_NAV_BG};
                border: 2px solid {COLOR_BORDER};
                border-radius: {container_radius}px;
            }}

            /* Highlight widget for selected button */
            #Highlight {{
                background-color: {COLOR_HIGHLIGHT_BG};
                border: 1px solid {COLOR_BORDER};
                border-radius: {inner_radius}px;
            }}

            /* Hover highlight widget */
            #HoverHighlight {{
                background-color: {COLOR_BUTTON_HOVER_BG};
                border-radius: {inner_radius}px;
            }}

            /* Button styles */
            #NavBarContainer QPushButton#NavButton {{
                font-family: {FONT_FAMILY_MONO};
                font-size: {FONT_SIZE_XS}pt;
                font-weight: bold;
                color: {COLOR_TEXT_NORMAL};
                border: none;
                background-color: transparent;
                padding: 8px 16px;
                border-radius: {inner_radius}px;
                outline: none;
                min-height: {self.height() - self.layout.contentsMargins().top() * 2 - 4}px;
            }}

            /* Button hover state - changes text color only */
            #NavBarContainer QPushButton#NavButton:hover {{
                color: {COLOR_TEXT_HOVER};
            }}

            /* Selected button state */
            #NavBarContainer QPushButton#NavButton[selected="true"] {{
                color: {COLOR_TEXT_SELECTED};
                background-color: transparent;
            }}
        """
        self.setStyleSheet(styles)


class HomeWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Yaakai Navigation")
        self.setGeometry(300, 300, 700, 300)

        palette = self.palette()
        palette.setColor(QPalette.ColorRole.Window, QColor(COLOR_BG_MAIN))
        self.setAutoFillBackground(True)
        self.setPalette(palette)

        # Main layout
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)

        # Create rounded border container
        rounded_container = QWidget()
        rounded_container.setObjectName("RoundedContainer")

        # Create the rounded border widget
        self.border_widget = RoundedBorderWidget(rounded_container)
        self.border_widget.setGeometry(0, 0, 550, 150)  # Size includes padding

        # Layout for the rounded container's contents
        container_layout = QVBoxLayout(rounded_container)
        container_layout.setContentsMargins(OUTER_PADDING, OUTER_PADDING, OUTER_PADDING, OUTER_PADDING)

        # Add navbar to container
        self.nav_bar = NavigationBarYaakai()
        container_layout.addWidget(self.nav_bar, 0, Qt.AlignmentFlag.AlignCenter)

        # Add container to main layout (centered)
        main_layout.addWidget(rounded_container, 0, Qt.AlignmentFlag.AlignCenter)

        # Set mono font
        self.setFont(QFont(FONT_FAMILY_MONO))

        # Adjust border widget position after layout
        QTimer.singleShot(0, self._adjust_border_widget)

    def _adjust_border_widget(self):
        """Ensure border widget matches container size"""
        container = self.findChild(QWidget, "RoundedContainer")
        if container:
            self.border_widget.setGeometry(0, 0, container.width(), container.height())

    def resizeEvent(self, event):
        super().resizeEvent(event)
        self._adjust_border_widget()


if __name__ == '__main__':
    app = QApplication(sys.argv)
    window = HomeWindow()
    window.show()
    sys.exit(app.exec())


here is the main part - how the application should work .. the application must only i administravtive acces for windows and for linux with sudo access
1st when the application is opened for the 1st time the loginpage.py will open and ask for the login credentails.. the email id, password, country(the country should be automatically detceted by system itself and if the country detected by the user is not the country of the user then h/she can change the country from the dropdown button of the country/region section ) after entering this and logging with the registered email id - the email id should be registered when downloading from the website if the email is not registered then the application should not open and if the user is opening for the 2nd time (the user already logged in ) then the login page should not open 
and after the login process the mainpage.py will show up .. and when the mainpage is opened up then the vpn_detection.py code should start running .. and the output from the vpn_detection.py code should be displayed in the mainpage.py .. in the mainpage.py i have created 4 sections vpn status , public ip , local ip, activity log... in the out of the vpn_detection.py code  i have made the output like this only .. in the output of the vpn_detection.py there will be heading as vpn_status it should be displayed in the vpn status of the mainpage.py and the public ip - output from the vpn_detection.py this should be displayed under public ip in the mainpage.py and the local ip - output from the vpn_detection.py this should be displayed under the mainpage.py .. and there will be 3 buttons below all these if the start blocking button is clicked then the vpn_blocking button should start to run .. and the outputs from the vpn blocking should be stored in the activity log section of the mainpage.py and when the refresh button is clicked then the vpn_detection.py code should start again from the 1st and if the export button is clicked at the time of clicking what are the output that are dispalyed at the mainpage,py should be exported as html page and downloaded in the system storage ..all the values that are displayed on the mainpage.py should be stored in the supabase backend , in the backend supabase if vpn is connected and detected it should save in one table and if the vpn is not connected and not detceted then it should save in another table .. 
in the dashboardpage.py .. it should create a pie chart of about total no.of times the application is runned and that gragh is segregated into 2 section the 2 section of the pie chart are vpn detected and vpn not detceted this should be in 2 different colurs (these total no.of times the vpn connected and the vpn not connected data should be fetched from the supabase backend) and below these there will be 2 section no.of times the vpn detected and no.of times the vpn not detected and inside these sections the details like the ip, location of ip,  isp , corrdinates should be present the same applies for both the sections , what are the values that are recorded in the public ip section of the mainpage.py( the same as the output of the vpn_dectetion.py) should be present in there ..in the vpn connected section if the dashboardpage.py it should fetch the data from the vpn connected and detceted table of the supabase backend and... in the vpn not connected table it should fetch the data from the vpn not connected and not detected table from the supabase backend ... 
in the profilepage.py .. it should display the details that the users have entered at the time of login and there is a edit profile button if clicked on that then the users can change the details of them .. d  if the user decided change the account there is a logout button and if clicked on this link then the account is logged out once logged out the user will need to signing and then only he /she can open the application and start again .. and there is another button called as the delete button is the user clicks on the button then the account of the user is deleted even from the supabase .. 
there must be footer (i have the code for it) that is placed at the bottom of every page ( except the login page - which is opened only at the start of the page) ..
similarly i there must be  a navbar.py ( i have the codes for this also) this should be placed in the right side top corner below the header for which i ahve left the space .. through this navbar.py only the users can shift or change between pages .. 
and in the left of the navbar.py there will a logo of the application that is present in all the 3 pages .. 
the application is created not for full sized windows and created like only for a medium sized of the screen and cannot be made into full size .. 
this is complete working of my application .. now below all this i will give the code for all the files 
the work of u is to analyse the working which i have given to u above and create the structure for the above working requirments ..
